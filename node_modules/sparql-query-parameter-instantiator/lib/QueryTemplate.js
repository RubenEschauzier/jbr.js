"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryTemplate = void 0;
const sparqljs_1 = require("sparqljs");
/**
 * Data object for a query template.
 */
class QueryTemplate {
    constructor(syntaxTree, variableMappings) {
        this.syntaxTree = syntaxTree;
        this.variableMappings = variableMappings;
    }
    /**
     * Instantiate this template for the given counter value.
     * This counter value is used to determine what variable value should be used.
     * @param counter The current counter value.
     */
    instantiate(counter) {
        // Determine variables to instantiate with
        const variableMapping = {};
        for (const variable of Object.keys(this.variableMappings)) {
            const values = this.variableMappings[variable];
            if (values.length <= counter) {
                throw new Error(`Attempted to instantiate a query template more than the number of provided subsitution parameters (${values.length})`);
            }
            variableMapping[variable] = values[counter];
        }
        // Instantiate syntax tree
        return new sparqljs_1.Generator().stringify(this.instantiateSyntaxTree(this.syntaxTree, variableMapping));
    }
    instantiateSyntaxTree(syntaxTree, variableMapping) {
        // Only allow SELECT queries
        if (syntaxTree.type !== 'query' || syntaxTree.queryType !== 'SELECT') {
            throw new Error(`Only instantiations of SELECT queries are supported`);
        }
        // Remove variables
        syntaxTree = Object.assign({}, syntaxTree);
        if (!(syntaxTree.variables.length === 1 &&
            'termType' in syntaxTree.variables[0] &&
            syntaxTree.variables[0].termType === 'Wildcard')) {
            syntaxTree.variables = syntaxTree.variables
                .filter((variable) => !('termType' in variable) ||
                variable.termType !== 'Variable' ||
                !(variable.value in variableMapping));
        }
        // Apply expressions in variables
        syntaxTree.variables = syntaxTree.variables.map(variable => {
            if ('expression' in variable) {
                variable.expression = this.instantiateExpression(variable.expression, variableMapping);
            }
            return variable;
        });
        // Handle where clause in a recursive manner
        syntaxTree.where = this.instantiatePatterns(syntaxTree.where, variableMapping);
        // Handle GROUP BY
        if (syntaxTree.group) {
            syntaxTree.group = syntaxTree.group
                .map(group => ({ expression: this.instantiateExpression(group.expression, variableMapping) }));
        }
        return syntaxTree;
    }
    instantiatePatterns(patterns, variableMapping) {
        // eslint-disable-next-line array-callback-return
        return patterns.map(pattern => {
            pattern = Object.assign({}, pattern);
            switch (pattern.type) {
                case 'query':
                    return this.instantiateSyntaxTree(pattern, variableMapping);
                case 'bgp':
                case 'graph':
                    if ('triples' in pattern) {
                        return {
                            type: 'bgp',
                            triples: pattern.triples.map(triple => this.instantiateTriple(triple, variableMapping)),
                        };
                    }
                    return {
                        type: 'graph',
                        name: pattern.name,
                        patterns: this.instantiatePatterns(pattern.patterns, variableMapping),
                    };
                case 'union':
                case 'group':
                case 'optional':
                case 'minus':
                case 'service':
                    return Object.assign(Object.assign({}, pattern), { patterns: this.instantiatePatterns(pattern.patterns, variableMapping) });
                case 'filter':
                case 'bind':
                    return Object.assign(Object.assign({}, pattern), { expression: this.instantiateExpression(pattern.expression, variableMapping) });
                case 'values':
                    return pattern;
            }
        });
    }
    instantiateExpression(expression, variableMapping) {
        if ('type' in expression) {
            switch (expression.type) {
                case 'group':
                case 'graph':
                    return Object.assign(Object.assign({}, expression), { patterns: this.instantiatePatterns(expression.patterns, variableMapping) });
                case 'bgp':
                    return Object.assign(Object.assign({}, expression), { triples: expression.triples.map(triple => this.instantiateTriple(triple, variableMapping)) });
                case 'operation':
                case 'functionCall':
                    return Object.assign(Object.assign({}, expression), { args: expression.args.map(arg => this.instantiateExpression(arg, variableMapping)) });
                case 'aggregate':
                    return Object.assign(Object.assign({}, expression), { expression: this.instantiateExpression(expression.expression, variableMapping) });
            }
        }
        else {
            return this.instantiateTerm(expression, variableMapping);
        }
    }
    instantiateTriple(triple, variableMapping) {
        return {
            subject: this.instantiateTerm(triple.subject, variableMapping),
            predicate: this.instantiateTerm(triple.predicate, variableMapping),
            object: this.instantiateTerm(triple.object, variableMapping),
        };
    }
    instantiateTerm(term, variableMapping) {
        if ('termType' in term && term.termType === 'Variable') {
            const variableName = term.value;
            const variableValue = variableMapping[variableName];
            if (variableValue) {
                return variableValue;
            }
        }
        return term;
    }
}
exports.QueryTemplate = QueryTemplate;
//# sourceMappingURL=QueryTemplate.js.map