{"version":3,"file":"QueryTemplate.js","sourceRoot":"","sources":["QueryTemplate.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport type { BlankTerm,\n  IriTerm,\n  Pattern, QuadTerm,\n  SparqlQuery,\n  Triple,\n  Variable,\n  VariableExpression,\n  VariableTerm,\n  SelectQuery,\n  PropertyPath,\n  Term,\n  Expression } from 'sparqljs';\nimport { Generator } from 'sparqljs';\n\n/**\n * Data object for a query template.\n */\nexport class QueryTemplate {\n  private readonly syntaxTree: SparqlQuery;\n  private readonly variableMappings: Record<string, RDF.Term[]>;\n\n  public constructor(\n    syntaxTree: SparqlQuery,\n    variableMappings: Record<string, RDF.Term[]>,\n  ) {\n    this.syntaxTree = syntaxTree;\n    this.variableMappings = variableMappings;\n  }\n\n  /**\n   * Instantiate this template for the given counter value.\n   * This counter value is used to determine what variable value should be used.\n   * @param counter The current counter value.\n   */\n  public instantiate(counter: number): string {\n    // Determine variables to instantiate with\n    const variableMapping: Record<string, RDF.Term> = {};\n    for (const variable of Object.keys(this.variableMappings)) {\n      const values = this.variableMappings[variable];\n      if (values.length <= counter) {\n        throw new Error(`Attempted to instantiate a query template more than the number of provided subsitution parameters (${values.length})`);\n      }\n      variableMapping[variable] = values[counter];\n    }\n\n    // Instantiate syntax tree\n    return new Generator().stringify(this.instantiateSyntaxTree(this.syntaxTree, variableMapping));\n  }\n\n  public instantiateSyntaxTree(syntaxTree: SparqlQuery, variableMapping: Record<string, RDF.Term>): SelectQuery {\n    // Only allow SELECT queries\n    if (syntaxTree.type !== 'query' || syntaxTree.queryType !== 'SELECT') {\n      throw new Error(`Only instantiations of SELECT queries are supported`);\n    }\n\n    // Remove variables\n    syntaxTree = { ...syntaxTree };\n    if (!(syntaxTree.variables.length === 1 &&\n      'termType' in syntaxTree.variables[0] &&\n      syntaxTree.variables[0].termType === 'Wildcard')) {\n      syntaxTree.variables = (<Variable[]> syntaxTree.variables)\n        .filter((variable: VariableExpression | VariableTerm) => !('termType' in variable) ||\n          variable.termType !== 'Variable' ||\n          !(variable.value in variableMapping));\n    }\n\n    // Apply expressions in variables\n    syntaxTree.variables = <any> syntaxTree.variables.map(variable => {\n      if ('expression' in variable) {\n        variable.expression = this.instantiateExpression(variable.expression, variableMapping);\n      }\n      return variable;\n    });\n\n    // Handle where clause in a recursive manner\n    syntaxTree.where = this.instantiatePatterns(syntaxTree.where!, variableMapping);\n\n    // Handle GROUP BY\n    if (syntaxTree.group) {\n      syntaxTree.group = syntaxTree.group\n        .map(group => ({ expression: this.instantiateExpression(group.expression, variableMapping) }));\n    }\n\n    return syntaxTree;\n  }\n\n  public instantiatePatterns(patterns: Pattern[], variableMapping: Record<string, RDF.Term>): Pattern[] {\n    // eslint-disable-next-line array-callback-return\n    return patterns.map(pattern => {\n      pattern = { ...pattern };\n      switch (pattern.type) {\n        case 'query':\n          return this.instantiateSyntaxTree(pattern, variableMapping);\n        case 'bgp':\n        case 'graph':\n          if ('triples' in pattern) {\n            return {\n              type: 'bgp',\n              triples: pattern.triples.map(triple => this.instantiateTriple(triple, variableMapping)),\n            };\n          }\n          return {\n            type: 'graph',\n            name: pattern.name,\n            patterns: this.instantiatePatterns(pattern.patterns, variableMapping),\n          };\n        case 'union':\n        case 'group':\n        case 'optional':\n        case 'minus':\n        case 'service':\n          return {\n            ...pattern,\n            patterns: this.instantiatePatterns(pattern.patterns, variableMapping),\n          };\n        case 'filter':\n        case 'bind':\n          return {\n            ...pattern,\n            expression: this.instantiateExpression(pattern.expression, variableMapping),\n          };\n        case 'values':\n          return pattern;\n      }\n    });\n  }\n\n  public instantiateExpression(expression: Expression, variableMapping: Record<string, RDF.Term>): Expression {\n    if ('type' in expression) {\n      switch (expression.type) {\n        case 'group':\n        case 'graph':\n          return {\n            ...expression,\n            patterns: this.instantiatePatterns(expression.patterns, variableMapping),\n          };\n        case 'bgp':\n          return {\n            ...expression,\n            triples: expression.triples.map(triple => this.instantiateTriple(triple, variableMapping)),\n          };\n        case 'operation':\n        case 'functionCall':\n          return {\n            ...expression,\n            args: expression.args.map(arg => this.instantiateExpression(arg, variableMapping)),\n          };\n        case 'aggregate':\n          return {\n            ...expression,\n            expression: this.instantiateExpression(expression.expression, variableMapping),\n          };\n      }\n    } else {\n      return <Expression> this.instantiateTerm(<Term> expression, variableMapping);\n    }\n  }\n\n  public instantiateTriple(triple: Triple, variableMapping: Record<string, RDF.Term>): Triple {\n    return {\n      subject: <any> this.instantiateTerm(triple.subject, variableMapping),\n      predicate: <any> this.instantiateTerm(triple.predicate, variableMapping),\n      object: <any> this.instantiateTerm(triple.object, variableMapping),\n    };\n  }\n\n  public instantiateTerm<T extends IriTerm | BlankTerm | VariableTerm | QuadTerm | PropertyPath | Term>(\n    term: T,\n    variableMapping: Record<string, RDF.Term>,\n  ): T | RDF.Term {\n    if ('termType' in term && (<RDF.Term> term).termType === 'Variable') {\n      const variableName = (<VariableTerm> term).value;\n      const variableValue = variableMapping[variableName];\n      if (variableValue) {\n        return variableValue;\n      }\n    }\n    return term;\n  }\n}\n"]}