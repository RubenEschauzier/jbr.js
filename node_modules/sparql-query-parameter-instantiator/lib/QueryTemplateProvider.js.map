{"version":3,"file":"QueryTemplateProvider.js","sourceRoot":"","sources":["QueryTemplateProvider.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,yBAAyB;AAGzB,uCAAkC;AAClC,mDAAgD;AAGhD;;GAEG;AACH,MAAa,qBAAqB;IAOhC,YACE,gBAAwB,EACxB,mBAA2B,EAC3B,SAA8B;QAE9B,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;QACzC,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;QAC/C,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAE3B,IAAI,CAAC,MAAM,GAAG,IAAI,iBAAM,EAAE,CAAC;IAC7B,CAAC;IAED;;OAEG;IACU,cAAc;;YACzB,MAAM,YAAY,GAAG,MAAM,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,EAAE,MAAM,CAAC,CAAC;YAC/E,MAAM,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;YACnD,MAAM,gBAAgB,GAA+B,EAAE,CAAC;YACxD,KAAK,MAAM,gBAAgB,IAAI,IAAI,CAAC,SAAS,EAAE;gBAC7C,MAAM,YAAY,GAAG,gBAAgB,CAAC,OAAO,EAAE,CAAC;gBAChD,MAAM,oBAAoB,GAAG,gBAAgB,CAAC,uBAAuB,EAAE,CAAC;gBACxE,IAAI,CAAC,oBAAoB,EAAE;oBACzB,MAAM,IAAI,KAAK,CAAC,0BAA0B,IAAI,CAAC,gBAAgB,UAAU,YAAY,2CAA2C,CAAC,CAAC;iBACnI;gBACD,gBAAgB,CAAC,YAAY,CAAC,GAAG,CAAC,MAAM,oBAAoB,CAAC,SAAS,EAAE,CAAC;qBACtE,GAAG,CAAC,KAAK,CAAC,EAAE,CAAC,gBAAgB,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC;aACrD;YACD,OAAO,IAAI,6BAAa,CAAC,UAAU,EAAE,gBAAgB,CAAC,CAAC;QACzD,CAAC;KAAA;IAED;;;OAGG;IACU,eAAe,CAAC,WAAmB;;YAC9C,MAAM,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,IAAI,CAAC,mBAAmB,EAAE,WAAW,EAAE,MAAM,CAAC,CAAC;QAC7E,CAAC;KAAA;CACF;AA7CD,sDA6CC","sourcesContent":["import * as fs from 'fs';\nimport type * as RDF from '@rdfjs/types';\nimport type { SparqlParser } from 'sparqljs';\nimport { Parser } from 'sparqljs';\nimport { QueryTemplate } from './QueryTemplate';\nimport type { IVariableTemplate } from './variable/IVariableTemplate';\n\n/**\n * Constructs query templates based on a given template file, variables, and substitution parameters.\n */\nexport class QueryTemplateProvider {\n  private readonly templateFilePath: string;\n  private readonly destinationFilePath: string;\n  private readonly variables: IVariableTemplate[];\n\n  private readonly parser: SparqlParser;\n\n  public constructor(\n    templateFilePath: string,\n    destinationFilePath: string,\n    variables: IVariableTemplate[],\n  ) {\n    this.templateFilePath = templateFilePath;\n    this.destinationFilePath = destinationFilePath;\n    this.variables = variables;\n\n    this.parser = new Parser();\n  }\n\n  /**\n   * Create a new query template data object.\n   */\n  public async createTemplate(): Promise<QueryTemplate> {\n    const sparqlString = await fs.promises.readFile(this.templateFilePath, 'utf8');\n    const syntaxTree = this.parser.parse(sparqlString);\n    const variableMappings: Record<string, RDF.Term[]> = {};\n    for (const variableTemplate of this.variables) {\n      const variableName = variableTemplate.getName();\n      const substitutionProvider = variableTemplate.getSubstitutionProvider();\n      if (!substitutionProvider) {\n        throw new Error(`The variable template '${this.templateFilePath}' for '${variableName}' has no substitution provider configured`);\n      }\n      variableMappings[variableName] = (await substitutionProvider.getValues())\n        .map(value => variableTemplate.createTerm(value));\n    }\n    return new QueryTemplate(syntaxTree, variableMappings);\n  }\n\n  /**\n   * Serialize the given queries file contents.\n   * @param queriesFile The contents of the queries file to serialize.\n   */\n  public async saveQueriesFile(queriesFile: string): Promise<void> {\n    await fs.promises.writeFile(this.destinationFilePath, queriesFile, 'utf8');\n  }\n}\n\n"]}