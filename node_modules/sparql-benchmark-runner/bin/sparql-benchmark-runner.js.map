{"version":3,"file":"sparql-benchmark-runner.js","sourceRoot":"","sources":["sparql-benchmark-runner.ts"],"names":[],"mappings":";;AAAA,+BAA+B;AAC/B,2CAAwC;AACxC,sEAAiF;AACjF,wEAAqE;AAErE,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG,KAAK,CAAC,IAAA,iBAAO,EAAC,OAAO,CAAC,IAAI,CAAC,CAAC;KAClD,OAAO,CAAC;IACP,QAAQ,EAAE;QACR,KAAK,EAAE,GAAG;QACV,IAAI,EAAE,QAAQ;QACd,QAAQ,EAAE,+CAA+C;QACzD,YAAY,EAAE,IAAI;KACnB;IACD,OAAO,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,QAAQ,EAAE,0BAA0B,EAAE,YAAY,EAAE,IAAI,EAAE;IACjG,WAAW,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,EAAE,QAAQ,EAAE,4BAA4B,EAAE;IAC/F,MAAM,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,CAAC,EAAE,QAAQ,EAAE,uBAAuB,EAAE;IACrF,MAAM,EAAE,EAAE,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,YAAY,EAAE,QAAQ,EAAE,qCAAqC,EAAE;IAC9G,UAAU,EAAE;QACV,KAAK,EAAE,GAAG;QACV,IAAI,EAAE,SAAS;QACf,OAAO,EAAE,KAAK;QACd,QAAQ,EAAE,kEAAkE;KAC7E;CACF,CAAC;KACD,IAAI,EAAE,CAAC;AAEV,CAAC,KAAK,UAAU,GAAG;IACjB,gBAAgB;IAChB,MAAM,OAAO,GAAG,MAAM,IAAI,6CAAqB,CAAC;QAC9C,QAAQ,EAAE,MAAM,CAAC,QAAQ;QACzB,SAAS,EAAE,MAAM,IAAA,kCAAW,EAAC,MAAM,CAAC,OAAO,CAAC;QAC5C,WAAW,EAAE,MAAM,CAAC,WAAW;QAC/B,MAAM,EAAE,MAAM,CAAC,MAAM;QACrB,mBAAmB,EAAE,MAAM,CAAC,UAAU;QACtC,MAAM,EAAE,CAAC,OAAe,EAAE,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC;KAC3D,CAAC,CAAC,GAAG,EAAE,CAAC;IAET,gBAAgB;IAChB,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,sBAAsB,MAAM,CAAC,MAAM,IAAI,CAAC,CAAC;IAC9D,MAAM,IAAA,4CAAqB,EAAC,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,UAAU,CAAC,CAAC;AACzE,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,KAAY,EAAE,EAAE,CAAC,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAS,KAAK,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC","sourcesContent":["import * as yargs from 'yargs';\nimport { hideBin } from 'yargs/helpers';\nimport { readQueries, writeBenchmarkResults } from '../lib/BenchmarkInputOutput';\nimport { SparqlBenchmarkRunner } from '../lib/SparqlBenchmarkRunner';\n\nconst { argv: params } = yargs(hideBin(process.argv))\n  .options({\n    endpoint: {\n      alias: 'e',\n      type: 'string',\n      describe: 'URL of the SPARQL endpoint to send queries to',\n      demandOption: true,\n    },\n    queries: { alias: 'q', type: 'string', describe: 'Directory of the queries', demandOption: true },\n    replication: { alias: 'r', type: 'number', default: 5, describe: 'Number of replication runs' },\n    warmup: { alias: 'w', type: 'number', default: 0, describe: 'Number of warmup runs' },\n    output: { alias: 'o', type: 'string', default: 'output.csv', describe: 'Destination for the output CSV file' },\n    timestamps: {\n      alias: 't',\n      type: 'boolean',\n      default: false,\n      describe: 'If a timestamps column should be added with result arrival times',\n    },\n  })\n  .help();\n\n(async function run() {\n  // Run benchmark\n  const results = await new SparqlBenchmarkRunner({\n    endpoint: params.endpoint,\n    querySets: await readQueries(params.queries),\n    replication: params.replication,\n    warmup: params.warmup,\n    timestampsRecording: params.timestamps,\n    logger: (message: string) => process.stdout.write(message),\n  }).run();\n\n  // Write results\n  process.stdout.write(`Writing results to ${params.output}\\n`);\n  await writeBenchmarkResults(results, params.output, params.timestamps);\n})().catch((error: Error) => process.stderr.write(`${<any> error.stack}\\n`));\n"]}