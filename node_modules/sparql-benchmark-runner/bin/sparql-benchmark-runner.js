"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const yargs = require("yargs");
const helpers_1 = require("yargs/helpers");
const BenchmarkInputOutput_1 = require("../lib/BenchmarkInputOutput");
const SparqlBenchmarkRunner_1 = require("../lib/SparqlBenchmarkRunner");
const { argv: params } = yargs((0, helpers_1.hideBin)(process.argv))
    .options({
    endpoint: {
        alias: 'e',
        type: 'string',
        describe: 'URL of the SPARQL endpoint to send queries to',
        demandOption: true,
    },
    queries: { alias: 'q', type: 'string', describe: 'Directory of the queries', demandOption: true },
    replication: { alias: 'r', type: 'number', default: 5, describe: 'Number of replication runs' },
    warmup: { alias: 'w', type: 'number', default: 0, describe: 'Number of warmup runs' },
    output: { alias: 'o', type: 'string', default: 'output.csv', describe: 'Destination for the output CSV file' },
    timestamps: {
        alias: 't',
        type: 'boolean',
        default: false,
        describe: 'If a timestamps column should be added with result arrival times',
    },
})
    .help();
(async function run() {
    // Run benchmark
    const results = await new SparqlBenchmarkRunner_1.SparqlBenchmarkRunner({
        endpoint: params.endpoint,
        querySets: await (0, BenchmarkInputOutput_1.readQueries)(params.queries),
        replication: params.replication,
        warmup: params.warmup,
        timestampsRecording: params.timestamps,
        logger: (message) => process.stdout.write(message),
    }).run();
    // Write results
    process.stdout.write(`Writing results to ${params.output}\n`);
    await (0, BenchmarkInputOutput_1.writeBenchmarkResults)(results, params.output, params.timestamps);
})().catch((error) => process.stderr.write(`${error.stack}\n`));
//# sourceMappingURL=sparql-benchmark-runner.js.map