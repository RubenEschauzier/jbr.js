{"version":3,"file":"SparqlBenchmarkRunner.js","sourceRoot":"","sources":["SparqlBenchmarkRunner.ts"],"names":[],"mappings":"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","sourcesContent":["import { SparqlEndpointFetcher } from 'fetch-sparql-endpoint';\nimport type { IBenchmarkResults } from './IBenchmarkResults';\n\n/**\n * Executes query sets against a SPARQL endpoint.\n */\nexport class SparqlBenchmarkRunner {\n  private readonly endpoint: string;\n  private readonly querySets: Record<string, string[]>;\n  private readonly replication: number;\n  private readonly warmup: number;\n  private readonly timestampsRecording: boolean;\n  private readonly logger?: (message: string) => void;\n  private readonly upQuery: string;\n  private readonly additionalUrlParamsInit?: URLSearchParams;\n  private readonly additionalUrlParamsRun?: URLSearchParams;\n  private readonly timeout?: number;\n\n  public constructor(options: ISparqlBenchmarkRunnerArgs) {\n    this.endpoint = options.endpoint;\n    this.querySets = options.querySets;\n    this.replication = options.replication;\n    this.warmup = options.warmup;\n    this.timestampsRecording = options.timestampsRecording;\n    this.logger = options.logger;\n    this.upQuery = options.upQuery || 'SELECT * WHERE { ?s ?p ?o } LIMIT 1';\n    this.additionalUrlParamsInit = options.additionalUrlParamsInit;\n    this.additionalUrlParamsRun = options.additionalUrlParamsRun;\n    this.timeout = options.timeout;\n  }\n\n  /**\n   * Once the endpoint is live,\n   * execute all query sets against the SPARQL endpoint.\n   * Afterwards, all results are collected and averaged.\n   */\n  public async run(options: IRunOptions = {}): Promise<IBenchmarkResults> {\n    // Await query execution until the endpoint is live\n    await this.waitUntilUp();\n\n    // Execute queries in warmup\n    this.log(`Warming up for ${this.warmup} rounds\\n`);\n    await this.executeQueries({}, this.warmup);\n\n    // Execute queries\n    const results: IBenchmarkResults = {};\n    this.log(`Executing ${Object.keys(this.querySets).length} queries with replication ${this.replication}\\n`);\n    if (options.onStart) {\n      await options.onStart();\n    }\n    await this.executeQueries(results, this.replication);\n    if (options.onStop) {\n      await options.onStop();\n    }\n\n    // Average results\n    for (const key in results) {\n      results[key].time = Math.floor(results[key].time / this.replication);\n      results[key].timestamps = results[key].timestamps.map(t => Math.floor(t / this.replication));\n    }\n\n    return results;\n  }\n\n  /**\n   * Execute all queries against the endpoint.\n   * @param data The results to append to.\n   * @param iterations The number of times to iterate.\n   */\n  public async executeQueries(data: IBenchmarkResults, iterations: number): Promise<void> {\n    this.log('Executing query ');\n    for (let iteration = 0; iteration < iterations; iteration++) {\n      for (const name in this.querySets) {\n        const test = this.querySets[name];\n        // eslint-disable-next-line @typescript-eslint/no-for-in-array\n        for (const id in test) {\n          this.log(`\\rExecuting query ${name}:${id} for iteration ${iteration + 1}/${iterations}`);\n          const query = test[id];\n          let count: number;\n          let time: number;\n          let timestamps: number[];\n          let metadata: Record<string, any>;\n          let errorObject: Error | undefined;\n\n          // Execute query, and catch errors\n          try {\n            ({ count, time, timestamps, metadata } = await this.executeQuery(query));\n          } catch (error: unknown) {\n            errorObject = <Error> error;\n            if ('partialOutput' in <any> errorObject) {\n              ({ count, time, timestamps, metadata } = (<any>errorObject).partialOutput);\n            } else {\n              count = 0;\n              time = 0;\n              timestamps = [];\n              metadata = {};\n            }\n          }\n\n          // Store results\n          if (!data[name + id]) {\n            data[name + id] = { name, id, count, time, timestamps, error: Boolean(errorObject), metadata };\n          } else {\n            const dataEntry = data[name + id];\n\n            if (errorObject) {\n              dataEntry.error = true;\n            }\n\n            dataEntry.time += time;\n\n            // Combine timestamps\n            const length = Math.min(dataEntry.timestamps.length, timestamps.length);\n            for (let i = 0; i < length; ++i) {\n              dataEntry.timestamps[i] += timestamps[i];\n            }\n          }\n\n          // Delay if error\n          if (errorObject) {\n            this.log(`\\rError occurred at query ${name}:${id} for iteration ${iteration + 1}/${iterations}: ${errorObject.message}\\n`);\n\n            // Wait until the endpoint is properly live again\n            await this.sleep(3_000);\n            await this.waitUntilUp();\n          }\n        }\n      }\n    }\n    this.log(`\"\\rExecuted all queries\\n`);\n  }\n\n  /**\n   * Execute a single query\n   * @param query A SPARQL query string\n   */\n  public async executeQuery(query: string): Promise<{\n    count: number; time: number; timestamps: number[]; metadata: Record<string, any>;\n  }> {\n    const fetcher = new SparqlEndpointFetcher({\n      additionalUrlParams: this.additionalUrlParamsRun,\n    });\n    let promiseTimeout: Promise<any> | undefined;\n    let timeoutHandle: NodeJS.Timeout | undefined;\n    if (this.timeout) {\n      promiseTimeout = new Promise((resolve, reject) => {\n        timeoutHandle = <any> setTimeout(() => reject(new Error('Timeout for running query')), this.timeout);\n      });\n    }\n    const promiseFetch = fetcher.fetchBindings(this.endpoint, query)\n      .then(results => new Promise<{\n        count: number; time: number; timestamps: number[]; metadata: Record<string, any>;\n      }>((resolve, reject) => {\n        const hrstart = process.hrtime();\n        let count = 0;\n        const timestamps: number[] = [];\n        let metadata: Record<string, any> = {};\n        results.on('metadata', (readMetadata: any) => {\n          metadata = readMetadata;\n        });\n        results.on('data', () => {\n          count++;\n          if (this.timestampsRecording) {\n            timestamps.push(this.countTime(hrstart));\n          }\n        });\n        results.on('error', (error: any) => {\n          error.partialOutput = {\n            count,\n            time: this.countTime(hrstart),\n            timestamps,\n            metadata,\n          };\n          reject(error);\n        });\n        results.on('end', () => {\n          if (timeoutHandle) {\n            clearTimeout(timeoutHandle);\n          }\n          resolve({ count, time: this.countTime(hrstart), timestamps, metadata });\n        });\n      }));\n    return promiseTimeout ? Promise.race([ promiseTimeout, promiseFetch ]) : promiseFetch;\n  }\n\n  /**\n   * Based on a hrtime start, obtain the duration.\n   * @param hrstart process.hrtime\n   */\n  public countTime(hrstart: [number, number]): number {\n    const hrend = process.hrtime(hrstart);\n    return hrend[0] * 1_000 + hrend[1] / 1_000_000;\n  }\n\n  /**\n   * Check if the SPARQL endpoint is available.\n   */\n  public isUp(): Promise<boolean> {\n    const fetcher = new SparqlEndpointFetcher({\n      additionalUrlParams: this.additionalUrlParamsInit,\n    });\n    let timeoutHandle: NodeJS.Timeout | undefined;\n    const promiseTimeout = new Promise<boolean>(resolve => {\n      timeoutHandle = <any> setTimeout(() => resolve(false), 10_000);\n    });\n    const promiseFetch = fetcher.fetchBindings(this.endpoint, this.upQuery)\n      .then(results => new Promise<boolean>(resolve => {\n        results.on('error', () => {\n          clearTimeout(timeoutHandle);\n          resolve(false);\n        });\n        results.on('data', () => {\n          // Do nothing\n        });\n        results.on('end', () => {\n          clearTimeout(timeoutHandle);\n          resolve(true);\n        });\n      }));\n    return Promise.race([ promiseTimeout, promiseFetch ])\n      .catch(() => false);\n  }\n\n  /**\n   * Wait until the SPARQL endpoint is available.\n   */\n  public async waitUntilUp(): Promise<void> {\n    let counter = 0;\n    while (!await this.isUp()) {\n      await this.sleep(1_000);\n      this.log(`\\rEndpoint not available yet, waited for ${++counter} seconds...`);\n    }\n    this.log(`\\rEndpoint available after ${counter} seconds.\\n`);\n  }\n\n  /**\n   * Sleep for a given amount of time.\n   * @param durationMs A duration in milliseconds.\n   */\n  public async sleep(durationMs: number): Promise<void> {\n    return new Promise<void>(resolve => setTimeout(resolve, durationMs));\n  }\n\n  /**\n   * Log a message.\n   * @param message Message to log.\n   */\n  public log(message: string): void {\n    return this.logger?.call(this.logger, message);\n  }\n}\n\nexport interface ISparqlBenchmarkRunnerArgs {\n  /**\n   * URL of the SPARQL endpoint to send queries to.\n   */\n  endpoint: string;\n  /**\n   * Mapping of query set name to an array of SPARQL query strings in this set.\n   */\n  querySets: Record<string, string[]>;\n  /**\n   * Number of replication runs.\n   */\n  replication: number;\n  /**\n   * Number of warmup runs.\n   */\n  warmup: number;\n  /**\n   * If a timestamps column should be added with result arrival times.\n   */\n  timestampsRecording: boolean;\n  /**\n   * Destination for log messages.\n   * @param message Message to log.\n   */\n  logger?: (message: string) => void;\n  /**\n   * SPARQL SELECT query that will be sent to the endpoint to check if it is up.\n   */\n  upQuery?: string;\n  /**\n   * Additional URL parameters that must be sent to the endpoint when checking if the endpoint is up.\n   */\n  additionalUrlParamsInit?: URLSearchParams;\n  /**\n   * Additional URL parameters that must be sent to the endpoint during actual query execution.\n   */\n  additionalUrlParamsRun?: URLSearchParams;\n  /**\n   * A timeout for query execution in milliseconds.\n   *\n   * If the timeout is reached, the query request will NOT be aborted.\n   * Instead, the query is assumed to have silently failed.\n   *\n   * This timeout is only supposed to be used as a fallback to an endpoint-driven timeout.\n   */\n  timeout?: number;\n}\n\nexport interface IRunOptions {\n  /**\n   * A listener for when the actual query executions have started.\n   */\n  onStart?: () => Promise<void>;\n  /**\n   * A listener for when the actual query executions have stopped.\n   */\n  onStop?: () => Promise<void>;\n}\n"]}