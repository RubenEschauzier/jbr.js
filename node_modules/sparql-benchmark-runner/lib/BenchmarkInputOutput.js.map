{"version":3,"file":"BenchmarkInputOutput.js","sourceRoot":"","sources":["BenchmarkInputOutput.ts"],"names":[],"mappings":";;;AAAA,yBAAyB;AACzB,6BAA6B;AAG7B;;;;;;;;GAQG;AACI,KAAK,UAAU,WAAW,CAAC,cAAsB;IACtD,MAAM,SAAS,GAA6B,EAAE,CAAC;IAC/C,MAAM,SAAS,GAAG,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;SAC1D,MAAM,CAAC,CAAC,QAAgB,EAAE,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC;IAC3F,KAAK,MAAM,QAAQ,IAAI,SAAS,EAAE;QAChC,MAAM,OAAO,GAAG,CAAC,MAAM,EAAE,CAAC,QAAQ,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,cAAc,EAAE,QAAQ,CAAC,EAAE,MAAM,CAAC,CAAC;aACtF,KAAK,CAAC,MAAM,CAAC;aACb,MAAM,CAAC,KAAK,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;QACrC,MAAM,SAAS,GAAG,QAAQ,CAAC,OAAO,CAAC,QAAQ,EAAE,EAAE,CAAC,CAAC;QACjD,SAAS,CAAC,SAAS,CAAC,GAAG,OAAO,CAAC;KAChC;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAZD,kCAYC;AAED;;;;;;GAMG;AACI,KAAK,UAAU,qBAAqB,CACzC,OAA0B,EAC1B,UAAkB,EAClB,mBAA4B,EAC5B,eAAyB,EAAE;IAE3B,MAAM,GAAG,GAAG,EAAE,CAAC,iBAAiB,CAAC,UAAU,CAAC,CAAC;IAC7C,GAAG,CAAC,KAAK,CAAC,6BAA6B,mBAAmB,CAAC,CAAC,CAAC,aAAa,CAAC,CAAC,CAAC,EAAE,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,CAAC;IACnJ,KAAK,MAAM,GAAG,IAAI,OAAO,EAAE;QACzB,MAAM,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,UAAU,EAAE,QAAQ,EAAE,GAAG,OAAO,CAAC,GAAG,CAAC,CAAC;QAC5E,GAAG,CAAC,KAAK,CAAC,GAAG,IAAI,IAAI,EAAE,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,GAC/C,mBAAmB,CAAC,CAAC;YACnB,IAAI,UAAU,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YAC5B,EAAE,GACJ,YAAY,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACvB,IAAI,YAAY,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;YACxE,EAAE,IAAI,CAAC,CAAC;KACb;IACD,GAAG,CAAC,GAAG,EAAE,CAAC;AACZ,CAAC;AAnBD,sDAmBC","sourcesContent":["import * as fs from 'fs';\nimport * as Path from 'path';\nimport type { IBenchmarkResults } from './IBenchmarkResults';\n\n/**\n * Read query sets from a given directory.\n *\n * A directory can contain multiple files ending with the .txt or .sparql suffix.\n * Each of those files can contain multiple SPARQL queries, separated by empty lines.\n *\n * @param queryDirectory Path to a query directory.\n * @return Mapping of query set name to an array of SPARQL query strings in this set.\n */\nexport async function readQueries(queryDirectory: string): Promise<Record<string, string[]>> {\n  const querySets: Record<string, string[]> = {};\n  const filenames = (await fs.promises.readdir(queryDirectory))\n    .filter((filename: string) => filename.endsWith('.txt') || filename.endsWith('.sparql'));\n  for (const filename of filenames) {\n    const queries = (await fs.promises.readFile(Path.join(queryDirectory, filename), 'utf8'))\n      .split('\\n\\n')\n      .filter(query => query.length > 0);\n    const queryName = filename.replace(/\\..*$/u, '');\n    querySets[queryName] = queries;\n  }\n  return querySets;\n}\n\n/**\n * Write benchmark results to a CSV file.\n * @param results Benchmark results.\n * @param outputFile Destination CSV file path.\n * @param timestampsRecording If timestamps were recorded during benchmarking.\n * @param metadataKeys The keys inside the metadata to emit. These will also be added to the CSV file header.\n */\nexport async function writeBenchmarkResults(\n  results: IBenchmarkResults,\n  outputFile: string,\n  timestampsRecording: boolean,\n  metadataKeys: string[] = [],\n): Promise<void> {\n  const out = fs.createWriteStream(outputFile);\n  out.write(`name;id;results;time;error${timestampsRecording ? ';timestamps' : ''}${metadataKeys.length > 0 ? `;${metadataKeys.join(';')}` : ''}\\n`);\n  for (const key in results) {\n    const { name, id, count, time, error, timestamps, metadata } = results[key];\n    out.write(`${name};${id};${count};${time};${error}${\n      timestampsRecording ?\n        `;${timestamps.join(' ')}` :\n        ''}${\n      metadataKeys.length > 0 ?\n        `;${metadataKeys.map(metadataKey => metadata[metadataKey]).join(';')}` :\n        ''}\\n`);\n  }\n  out.end();\n}\n"]}