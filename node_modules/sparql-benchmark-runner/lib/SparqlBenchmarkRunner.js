"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SparqlBenchmarkRunner = void 0;
const fetch_sparql_endpoint_1 = require("fetch-sparql-endpoint");
/**
 * Executes query sets against a SPARQL endpoint.
 */
class SparqlBenchmarkRunner {
    constructor(options) {
        this.endpoint = options.endpoint;
        this.querySets = options.querySets;
        this.replication = options.replication;
        this.warmup = options.warmup;
        this.timestampsRecording = options.timestampsRecording;
        this.logger = options.logger;
        this.upQuery = options.upQuery || 'SELECT * WHERE { ?s ?p ?o } LIMIT 1';
        this.additionalUrlParamsInit = options.additionalUrlParamsInit;
        this.additionalUrlParamsRun = options.additionalUrlParamsRun;
        this.timeout = options.timeout;
    }
    /**
     * Once the endpoint is live,
     * execute all query sets against the SPARQL endpoint.
     * Afterwards, all results are collected and averaged.
     */
    async run(options = {}) {
        // Await query execution until the endpoint is live
        await this.waitUntilUp();
        // Execute queries in warmup
        this.log(`Warming up for ${this.warmup} rounds\n`);
        await this.executeQueries({}, this.warmup);
        // Execute queries
        const results = {};
        this.log(`Executing ${Object.keys(this.querySets).length} queries with replication ${this.replication}\n`);
        if (options.onStart) {
            await options.onStart();
        }
        await this.executeQueries(results, this.replication);
        if (options.onStop) {
            await options.onStop();
        }
        // Average results
        for (const key in results) {
            results[key].time = Math.floor(results[key].time / this.replication);
            results[key].timestamps = results[key].timestamps.map(t => Math.floor(t / this.replication));
        }
        return results;
    }
    /**
     * Execute all queries against the endpoint.
     * @param data The results to append to.
     * @param iterations The number of times to iterate.
     */
    async executeQueries(data, iterations) {
        this.log('Executing query ');
        for (let iteration = 0; iteration < iterations; iteration++) {
            for (const name in this.querySets) {
                const test = this.querySets[name];
                // eslint-disable-next-line @typescript-eslint/no-for-in-array
                for (const id in test) {
                    this.log(`\rExecuting query ${name}:${id} for iteration ${iteration + 1}/${iterations}`);
                    const query = test[id];
                    let count;
                    let time;
                    let timestamps;
                    let metadata;
                    let errorObject;
                    // Execute query, and catch errors
                    try {
                        ({ count, time, timestamps, metadata } = await this.executeQuery(query));
                    }
                    catch (error) {
                        errorObject = error;
                        if ('partialOutput' in errorObject) {
                            ({ count, time, timestamps, metadata } = errorObject.partialOutput);
                        }
                        else {
                            count = 0;
                            time = 0;
                            timestamps = [];
                            metadata = {};
                        }
                    }
                    // Store results
                    if (!data[name + id]) {
                        data[name + id] = { name, id, count, time, timestamps, error: Boolean(errorObject), metadata };
                    }
                    else {
                        const dataEntry = data[name + id];
                        if (errorObject) {
                            dataEntry.error = true;
                        }
                        dataEntry.time += time;
                        // Combine timestamps
                        const length = Math.min(dataEntry.timestamps.length, timestamps.length);
                        for (let i = 0; i < length; ++i) {
                            dataEntry.timestamps[i] += timestamps[i];
                        }
                    }
                    // Delay if error
                    if (errorObject) {
                        this.log(`\rError occurred at query ${name}:${id} for iteration ${iteration + 1}/${iterations}: ${errorObject.message}\n`);
                        // Wait until the endpoint is properly live again
                        await this.sleep(3000);
                        await this.waitUntilUp();
                    }
                }
            }
        }
        this.log(`"\rExecuted all queries\n`);
    }
    /**
     * Execute a single query
     * @param query A SPARQL query string
     */
    async executeQuery(query) {
        const fetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            additionalUrlParams: this.additionalUrlParamsRun,
        });
        let promiseTimeout;
        let timeoutHandle;
        if (this.timeout) {
            promiseTimeout = new Promise((resolve, reject) => {
                timeoutHandle = setTimeout(() => reject(new Error('Timeout for running query')), this.timeout);
            });
        }
        const promiseFetch = fetcher.fetchBindings(this.endpoint, query)
            .then(results => new Promise((resolve, reject) => {
            const hrstart = process.hrtime();
            let count = 0;
            const timestamps = [];
            let metadata = {};
            results.on('metadata', (readMetadata) => {
                metadata = readMetadata;
            });
            results.on('data', () => {
                count++;
                if (this.timestampsRecording) {
                    timestamps.push(this.countTime(hrstart));
                }
            });
            results.on('error', (error) => {
                error.partialOutput = {
                    count,
                    time: this.countTime(hrstart),
                    timestamps,
                    metadata,
                };
                reject(error);
            });
            results.on('end', () => {
                if (timeoutHandle) {
                    clearTimeout(timeoutHandle);
                }
                resolve({ count, time: this.countTime(hrstart), timestamps, metadata });
            });
        }));
        return promiseTimeout ? Promise.race([promiseTimeout, promiseFetch]) : promiseFetch;
    }
    /**
     * Based on a hrtime start, obtain the duration.
     * @param hrstart process.hrtime
     */
    countTime(hrstart) {
        const hrend = process.hrtime(hrstart);
        return hrend[0] * 1000 + hrend[1] / 1000000;
    }
    /**
     * Check if the SPARQL endpoint is available.
     */
    isUp() {
        const fetcher = new fetch_sparql_endpoint_1.SparqlEndpointFetcher({
            additionalUrlParams: this.additionalUrlParamsInit,
        });
        let timeoutHandle;
        const promiseTimeout = new Promise(resolve => {
            timeoutHandle = setTimeout(() => resolve(false), 10000);
        });
        const promiseFetch = fetcher.fetchBindings(this.endpoint, this.upQuery)
            .then(results => new Promise(resolve => {
            results.on('error', () => {
                clearTimeout(timeoutHandle);
                resolve(false);
            });
            results.on('data', () => {
                // Do nothing
            });
            results.on('end', () => {
                clearTimeout(timeoutHandle);
                resolve(true);
            });
        }));
        return Promise.race([promiseTimeout, promiseFetch])
            .catch(() => false);
    }
    /**
     * Wait until the SPARQL endpoint is available.
     */
    async waitUntilUp() {
        let counter = 0;
        while (!await this.isUp()) {
            await this.sleep(1000);
            this.log(`\rEndpoint not available yet, waited for ${++counter} seconds...`);
        }
        this.log(`\rEndpoint available after ${counter} seconds.\n`);
    }
    /**
     * Sleep for a given amount of time.
     * @param durationMs A duration in milliseconds.
     */
    async sleep(durationMs) {
        return new Promise(resolve => setTimeout(resolve, durationMs));
    }
    /**
     * Log a message.
     * @param message Message to log.
     */
    log(message) {
        var _a;
        return (_a = this.logger) === null || _a === void 0 ? void 0 : _a.call(this.logger, message);
    }
}
exports.SparqlBenchmarkRunner = SparqlBenchmarkRunner;
//# sourceMappingURL=SparqlBenchmarkRunner.js.map