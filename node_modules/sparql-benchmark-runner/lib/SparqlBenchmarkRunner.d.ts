import type { IBenchmarkResults } from './IBenchmarkResults';
/**
 * Executes query sets against a SPARQL endpoint.
 */
export declare class SparqlBenchmarkRunner {
    private readonly endpoint;
    private readonly querySets;
    private readonly replication;
    private readonly warmup;
    private readonly timestampsRecording;
    private readonly logger?;
    private readonly upQuery;
    private readonly additionalUrlParamsInit?;
    private readonly additionalUrlParamsRun?;
    private readonly timeout?;
    constructor(options: ISparqlBenchmarkRunnerArgs);
    /**
     * Once the endpoint is live,
     * execute all query sets against the SPARQL endpoint.
     * Afterwards, all results are collected and averaged.
     */
    run(options?: IRunOptions): Promise<IBenchmarkResults>;
    /**
     * Execute all queries against the endpoint.
     * @param data The results to append to.
     * @param iterations The number of times to iterate.
     */
    executeQueries(data: IBenchmarkResults, iterations: number): Promise<void>;
    /**
     * Execute a single query
     * @param query A SPARQL query string
     */
    executeQuery(query: string): Promise<{
        count: number;
        time: number;
        timestamps: number[];
        metadata: Record<string, any>;
    }>;
    /**
     * Based on a hrtime start, obtain the duration.
     * @param hrstart process.hrtime
     */
    countTime(hrstart: [number, number]): number;
    /**
     * Check if the SPARQL endpoint is available.
     */
    isUp(): Promise<boolean>;
    /**
     * Wait until the SPARQL endpoint is available.
     */
    waitUntilUp(): Promise<void>;
    /**
     * Sleep for a given amount of time.
     * @param durationMs A duration in milliseconds.
     */
    sleep(durationMs: number): Promise<void>;
    /**
     * Log a message.
     * @param message Message to log.
     */
    log(message: string): void;
}
export interface ISparqlBenchmarkRunnerArgs {
    /**
     * URL of the SPARQL endpoint to send queries to.
     */
    endpoint: string;
    /**
     * Mapping of query set name to an array of SPARQL query strings in this set.
     */
    querySets: Record<string, string[]>;
    /**
     * Number of replication runs.
     */
    replication: number;
    /**
     * Number of warmup runs.
     */
    warmup: number;
    /**
     * If a timestamps column should be added with result arrival times.
     */
    timestampsRecording: boolean;
    /**
     * Destination for log messages.
     * @param message Message to log.
     */
    logger?: (message: string) => void;
    /**
     * SPARQL SELECT query that will be sent to the endpoint to check if it is up.
     */
    upQuery?: string;
    /**
     * Additional URL parameters that must be sent to the endpoint when checking if the endpoint is up.
     */
    additionalUrlParamsInit?: URLSearchParams;
    /**
     * Additional URL parameters that must be sent to the endpoint during actual query execution.
     */
    additionalUrlParamsRun?: URLSearchParams;
    /**
     * A timeout for query execution in milliseconds.
     *
     * If the timeout is reached, the query request will NOT be aborted.
     * Instead, the query is assumed to have silently failed.
     *
     * This timeout is only supposed to be used as a fallback to an endpoint-driven timeout.
     */
    timeout?: number;
}
export interface IRunOptions {
    /**
     * A listener for when the actual query executions have started.
     */
    onStart?: () => Promise<void>;
    /**
     * A listener for when the actual query executions have stopped.
     */
    onStop?: () => Promise<void>;
}
