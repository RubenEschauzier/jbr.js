{"version":3,"file":"FragmentationStrategyException.js","sourceRoot":"","sources":["FragmentationStrategyException.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,mCAAqC;AAIrC,6FAA0F;AAG1F;;;GAGG;AACH,MAAa,8BAA+B,SAAQ,uEAAkC;IAMpF,YAAmB,QAAgC,EAAE,UAAiD;QACpG,KAAK,EAAE,CAAC;QACR,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;QACzB,IAAI,CAAC,UAAU,GAAG,UAAU,CAAC;IAC/B,CAAC;IAEY,QAAQ,CAAC,UAAiC,EAAE,QAAmB;;;;;YAC1E,iDAAiD;YACjD,6CAA6C;YAC7C,iEAAiE;YACjE,yFAAyF;YACzF,MAAM,cAAc,GAAG,IAAI,oBAAW,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;YAC7D,MAAM,eAAe,GAAG,IAAI,CAAC,QAAQ,CAAC,QAAQ,CAAC,cAAc,EAAE,QAAQ,CAAC,CAAC;YACzE,MAAM,gBAAgB,GAAG,EAAE,CAAC;YAC5B,MAAM,iBAAiB,GAAG,EAAE,CAAC;YAC7B,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,UAAU,EAAE;gBACvC,MAAM,MAAM,GAAG,IAAI,oBAAW,CAAC,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;gBACrD,gBAAgB,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;gBAC9B,MAAM,gBAAgB,GAAG,SAAS,CAAC,QAAQ,CAAC,QAAQ,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;gBACvE,iBAAiB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;aAC1C;YACD,IAAI,CAAC,KAAK,GAAG;gBACX,cAAc;gBACd,eAAe;gBACf,gBAAgB;gBAChB,iBAAiB;aAClB,CAAC;YAEF,wCAAwC;YACxC,MAAM,OAAM,QAAQ,YAAC,UAAU,EAAE,QAAQ,CAAC,CAAC;YAE3C,oBAAoB;YACpB,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,GAAG,EAAE,CAAC;YAChC,KAAK,MAAM,eAAe,IAAI,IAAI,CAAC,KAAK,CAAC,gBAAgB,EAAE;gBACzD,eAAe,CAAC,GAAG,EAAE,CAAC;aACvB;YAED,8CAA8C;YAC9C,MAAM,IAAI,CAAC,KAAK,CAAC,eAAe,CAAC;YACjC,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;YAEhD,IAAI,CAAC,KAAK,GAAG,SAAS,CAAC;QACzB,CAAC;KAAA;IAEe,UAAU,CAAC,IAAc,EAAE,QAAmB;;YAC5D,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;gBACf,MAAM,IAAI,KAAK,CAAC,2DAA2D,CAAC,CAAC;aAC9E;YAED,gDAAgD;YAChD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC/C,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;gBACrC,IAAI,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;oBACnC,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;oBAC1C,OAAO;iBACR;aACF;YAED,gEAAgE;YAChE,IAAI,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACvC,CAAC;KAAA;CACF;AAnED,wEAmEC;AASD,MAAa,mCAAmC;IAI9C,YAAmB,OAAqB,EAAE,QAAgC;QACxE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;IAC3B,CAAC;CACF;AARD,kFAQC","sourcesContent":["import type { Readable } from 'stream';\nimport { PassThrough } from 'stream';\nimport type * as RDF from '@rdfjs/types';\nimport type { IQuadSink } from '../io/IQuadSink';\nimport type { IQuadMatcher } from '../quadmatcher/IQuadMatcher';\nimport { FragmentationStrategyStreamAdapter } from './FragmentationStrategyStreamAdapter';\nimport type { IFragmentationStrategy } from './IFragmentationStrategy';\n\n/**\n * A fragmentation strategy that delegates all but the listed exceptions to a given strategy.\n * The exceptions are handled via matchers, that can delegate to another strategy.\n */\nexport class FragmentationStrategyException extends FragmentationStrategyStreamAdapter {\n  private readonly strategy: IFragmentationStrategy;\n  private readonly exceptions: FragmentationStrategyExceptionEntry[];\n\n  private state: IStreamState | undefined;\n\n  public constructor(strategy: IFragmentationStrategy, exceptions: FragmentationStrategyExceptionEntry[]) {\n    super();\n    this.strategy = strategy;\n    this.exceptions = exceptions;\n  }\n\n  public async fragment(quadStream: RDF.Stream & Readable, quadSink: IQuadSink): Promise<void> {\n    // Create streams in which we can push our quads,\n    // and start fragmenting on these new streams\n    // Streams are created for our base strategy, and all exceptions.\n    // We also keep a pointer to the fragmenter's promise, which we will await upon flushing.\n    const strategyStream = new PassThrough({ objectMode: true });\n    const strategyPromise = this.strategy.fragment(strategyStream, quadSink);\n    const exceptionStreams = [];\n    const exceptionPromises = [];\n    for (const exception of this.exceptions) {\n      const stream = new PassThrough({ objectMode: true });\n      exceptionStreams.push(stream);\n      const exceptionPromise = exception.strategy.fragment(stream, quadSink);\n      exceptionPromises.push(exceptionPromise);\n    }\n    this.state = {\n      strategyStream,\n      strategyPromise,\n      exceptionStreams,\n      exceptionPromises,\n    };\n\n    // Call handleQuad in a streaming manner\n    await super.fragment(quadStream, quadSink);\n\n    // Close our streams\n    this.state.strategyStream.end();\n    for (const exceptionStream of this.state.exceptionStreams) {\n      exceptionStream.end();\n    }\n\n    // Wait on the fragmentation strategies to end\n    await this.state.strategyPromise;\n    await Promise.all(this.state.exceptionPromises);\n\n    this.state = undefined;\n  }\n\n  protected async handleQuad(quad: RDF.Quad, quadSink: IQuadSink): Promise<void> {\n    if (!this.state) {\n      throw new Error('Illegal state: handleQuad can only be called via fragment');\n    }\n\n    // Push the quad to the first matching exception\n    for (let i = 0; i < this.exceptions.length; i++) {\n      const exception = this.exceptions[i];\n      if (exception.matcher.matches(quad)) {\n        this.state.exceptionStreams[i].push(quad);\n        return;\n      }\n    }\n\n    // If not exceptions matched, push the quad to our base strategy\n    this.state.strategyStream.push(quad);\n  }\n}\n\nexport interface IStreamState {\n  strategyStream: PassThrough;\n  strategyPromise: Promise<void>;\n  exceptionStreams: PassThrough[];\n  exceptionPromises: Promise<void>[];\n}\n\nexport class FragmentationStrategyExceptionEntry {\n  public readonly matcher: IQuadMatcher;\n  public readonly strategy: IFragmentationStrategy;\n\n  public constructor(matcher: IQuadMatcher, strategy: IFragmentationStrategy) {\n    this.matcher = matcher;\n    this.strategy = strategy;\n  }\n}\n"]}