{"version":3,"file":"FragmentationStrategyStreamAdapter.js","sourceRoot":"","sources":["FragmentationStrategyStreamAdapter.ts"],"names":[],"mappings":";;;;;;;;;;;;AACA,mCAAmC;AAKnC;;GAEG;AACH,MAAsB,kCAAkC;IACzC,QAAQ,CAAC,UAAiC,EAAE,QAAmB;;YAC1E,4EAA4E;YAC5E,MAAM,IAAI,GAAG,IAAI,CAAC;YAClB,MAAM,SAAS,GAAG,IAAI,kBAAS,CAAC;gBAC9B,UAAU,EAAE,IAAI;gBAChB,oCAAoC;gBACpC,SAAS,CAAC,IAAc,EAAE,QAAwB,EAAE,QAA2B;oBAC7E,IAAI,CAAC,UAAU,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC,IAAI,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,EAAE,QAAQ,CAAC,CAAC;gBACnE,CAAC;aACF,CAAC,CAAC;YAEH,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBACpC,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,KAAK,CAAC,EAAE,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;gBAClE,MAAM,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;gBAC/C,0DAA0D;gBAC1D,WAAW,CAAC,MAAM,EAAE,CAAC;gBACrB,WAAW,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;gBAChC,WAAW,CAAC,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACjC,CAAC,CAAC,CAAC;YAEH,MAAM,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAC7B,CAAC;KAAA;IAIe,KAAK,CAAC,QAAmB;;YACvC,sEAAsE;QACxE,CAAC;KAAA;CACF;AA7BD,gFA6BC","sourcesContent":["import type { Readable, TransformCallback } from 'stream';\nimport { Transform } from 'stream';\nimport type * as RDF from '@rdfjs/types';\nimport type { IQuadSink } from '../io/IQuadSink';\nimport type { IFragmentationStrategy } from './IFragmentationStrategy';\n\n/**\n * An abstract implementation of a fragmentation strategy.\n */\nexport abstract class FragmentationStrategyStreamAdapter implements IFragmentationStrategy {\n  public async fragment(quadStream: RDF.Stream & Readable, quadSink: IQuadSink): Promise<void> {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n    const self = this;\n    const transform = new Transform({\n      objectMode: true,\n      // eslint-disable-next-line no-undef\n      transform(quad: RDF.Quad, encoding: BufferEncoding, callback: TransformCallback) {\n        self.handleQuad(quad, quadSink).then(() => callback(), callback);\n      },\n    });\n\n    await new Promise((resolve, reject) => {\n      quadStream.on('error', error => transformed.emit('error', error));\n      const transformed = quadStream.pipe(transform);\n      // Enter flow-mode, but not need to attach a data-listener\n      transformed.resume();\n      transformed.on('error', reject);\n      transformed.on('end', resolve);\n    });\n\n    await this.flush(quadSink);\n  }\n\n  protected abstract handleQuad(quad: RDF.Quad, quadSink: IQuadSink): Promise<void>;\n\n  protected async flush(quadSink: IQuadSink): Promise<void> {\n    // Do nothing, implementors of this class can optionally override this\n  }\n}\n"]}