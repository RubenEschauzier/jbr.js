"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FragmentationStrategyExceptionEntry = exports.FragmentationStrategyException = void 0;
const stream_1 = require("stream");
const FragmentationStrategyStreamAdapter_1 = require("./FragmentationStrategyStreamAdapter");
/**
 * A fragmentation strategy that delegates all but the listed exceptions to a given strategy.
 * The exceptions are handled via matchers, that can delegate to another strategy.
 */
class FragmentationStrategyException extends FragmentationStrategyStreamAdapter_1.FragmentationStrategyStreamAdapter {
    constructor(strategy, exceptions) {
        super();
        this.strategy = strategy;
        this.exceptions = exceptions;
    }
    fragment(quadStream, quadSink) {
        const _super = Object.create(null, {
            fragment: { get: () => super.fragment }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // Create streams in which we can push our quads,
            // and start fragmenting on these new streams
            // Streams are created for our base strategy, and all exceptions.
            // We also keep a pointer to the fragmenter's promise, which we will await upon flushing.
            const strategyStream = new stream_1.PassThrough({ objectMode: true });
            const strategyPromise = this.strategy.fragment(strategyStream, quadSink);
            const exceptionStreams = [];
            const exceptionPromises = [];
            for (const exception of this.exceptions) {
                const stream = new stream_1.PassThrough({ objectMode: true });
                exceptionStreams.push(stream);
                const exceptionPromise = exception.strategy.fragment(stream, quadSink);
                exceptionPromises.push(exceptionPromise);
            }
            this.state = {
                strategyStream,
                strategyPromise,
                exceptionStreams,
                exceptionPromises,
            };
            // Call handleQuad in a streaming manner
            yield _super.fragment.call(this, quadStream, quadSink);
            // Close our streams
            this.state.strategyStream.end();
            for (const exceptionStream of this.state.exceptionStreams) {
                exceptionStream.end();
            }
            // Wait on the fragmentation strategies to end
            yield this.state.strategyPromise;
            yield Promise.all(this.state.exceptionPromises);
            this.state = undefined;
        });
    }
    handleQuad(quad, quadSink) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.state) {
                throw new Error('Illegal state: handleQuad can only be called via fragment');
            }
            // Push the quad to the first matching exception
            for (let i = 0; i < this.exceptions.length; i++) {
                const exception = this.exceptions[i];
                if (exception.matcher.matches(quad)) {
                    this.state.exceptionStreams[i].push(quad);
                    return;
                }
            }
            // If not exceptions matched, push the quad to our base strategy
            this.state.strategyStream.push(quad);
        });
    }
}
exports.FragmentationStrategyException = FragmentationStrategyException;
class FragmentationStrategyExceptionEntry {
    constructor(matcher, strategy) {
        this.matcher = matcher;
        this.strategy = strategy;
    }
}
exports.FragmentationStrategyExceptionEntry = FragmentationStrategyExceptionEntry;
//# sourceMappingURL=FragmentationStrategyException.js.map