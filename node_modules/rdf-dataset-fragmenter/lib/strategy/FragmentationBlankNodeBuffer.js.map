{"version":3,"file":"FragmentationBlankNodeBuffer.js","sourceRoot":"","sources":["FragmentationBlankNodeBuffer.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { quadToStringQuad } from 'rdf-string';\nimport type { QuadTermName } from 'rdf-terms';\nimport type { IQuadSink } from '../io/IQuadSink';\n\n/**\n * Buffers quads with blank nodes keys, and makes connections to non-blank node keys.\n */\nexport class FragmentationBlankNodeBuffer<A extends QuadTermName, B extends QuadTermName> {\n  private readonly keyKey: A;\n  private readonly keyValue: B;\n  private readonly valueKeyLinks: Record<string, RDF.NamedNode[]> = {};\n  private readonly pendingBlankKeyQuads: Record<string, RDF.Quad[]> = {};\n  private readonly eagerFlushing: boolean;\n\n  /**\n   * @param keyKey @ignored The quad term key that should be checked for blank nodes.\n   * @param keyValue @ignored The quad term value that may have a connection to the key.\n   * @param eagerFlushing @ignored If the pending quads in the buffer should be flushed as soon as possible.\n   */\n  public constructor(keyKey: A, keyValue: B, eagerFlushing: boolean) {\n    this.keyKey = keyKey;\n    this.keyValue = keyValue;\n    this.eagerFlushing = eagerFlushing;\n  }\n\n  /**\n   * Add the given quad into the buffer.\n   * If the quad's key is a blank node, it will be stored inside the internal buffer.\n   * @param quad An RDF quad.\n   * @param quadSink The quad sink to push into.\n   */\n  public async push(quad: RDF.Quad, quadSink: IQuadSink): Promise<void> {\n    // If key is a blank node, buffer it\n    if (quad[this.keyKey].termType === 'BlankNode') {\n      if (!(quad[this.keyKey].value in this.pendingBlankKeyQuads)) {\n        this.pendingBlankKeyQuads[quad[this.keyKey].value] = [];\n      }\n      this.pendingBlankKeyQuads[quad[this.keyKey].value].push(quad);\n\n      if (this.eagerFlushing) {\n        await this.attemptFlushQuadsForLabel(quad[this.keyKey].value, quadSink);\n      }\n    }\n  }\n\n  /**\n   * If the given term value is a blank node, it will be stored in the internal link registry.\n   * @param value A quad value term.\n   * @param key A quad key term.\n   * @param quadSink The quad sink to push into.\n   */\n  public async materializeValueForNamedKey(value: RDF.Term, key: RDF.NamedNode, quadSink: IQuadSink): Promise<void> {\n    if (value.termType === 'BlankNode') {\n      if (!(value.value in this.valueKeyLinks)) {\n        this.valueKeyLinks[value.value] = [];\n      }\n      this.valueKeyLinks[value.value].push(key);\n\n      if (this.eagerFlushing) {\n        await this.attemptFlushQuadsForLabel(value.value, quadSink);\n      }\n    }\n  }\n\n  /**\n   * Try to flush all quads connected to the given blank node label.\n   * All flushed quads will be removed from the queue (`pendingBlankKeyQuads`).\n   * The value key links will remain unchanged.\n   * @param blankNodeLabel A blank node label.\n   * @param quadSink The sink to push into.\n   */\n  protected async attemptFlushQuadsForLabel(blankNodeLabel: string, quadSink: IQuadSink): Promise<boolean> {\n    const quads = this.pendingBlankKeyQuads[blankNodeLabel];\n    const keys = this.valueKeyLinks[blankNodeLabel];\n    if (quads && keys) {\n      for (const key of keys) {\n        // Add the quad to the key's document.\n        for (const quad of quads) {\n          await quadSink.push(key.value, quad);\n\n          // Add a key link for the current key, as we may need it in the next iteration\n          await this.materializeValueForNamedKey(quad[this.keyValue], key, quadSink);\n        }\n      }\n\n      // Remove the blank node label from the queue, and indicate that we need to repeat the loop\n      delete this.pendingBlankKeyQuads[blankNodeLabel];\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Iterate over the buffer, and emit all quads with blank node keys that have a connection to a non-blank node key.\n   * @param quadSink The quad sink to push into.\n   */\n  public async flush(quadSink: IQuadSink): Promise<void> {\n    // Loop until the pendingBlankSubjectQuads queue does not change anymore\n    let changed = true;\n    while (changed) {\n      changed = false;\n      for (const blankNodeLabel of Object.keys(this.pendingBlankKeyQuads)) {\n        if (await this.attemptFlushQuadsForLabel(blankNodeLabel, quadSink)) {\n          changed = true;\n        }\n      }\n    }\n\n    // Error if there are unowned blank nodes\n    if (Object.keys(this.pendingBlankKeyQuads).length > 0) {\n      // eslint-disable-next-line no-console\n      console.warn(`Detected quads with blank node ${this.keyKey} that has no link to an IRI ${this.keyKey}:`);\n      for (const quads of Object.values(this.pendingBlankKeyQuads)) {\n        for (const quad of quads) {\n          // eslint-disable-next-line no-console\n          console.warn(`  ${JSON.stringify(quadToStringQuad(quad))}`);\n        }\n      }\n    }\n  }\n}\n"]}