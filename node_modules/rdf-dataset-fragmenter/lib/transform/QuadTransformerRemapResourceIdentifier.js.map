{"version":3,"file":"QuadTransformerRemapResourceIdentifier.js","sourceRoot":"","sources":["QuadTransformerRemapResourceIdentifier.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\nimport { DataFactory } from 'rdf-data-factory';\nimport { resolve } from 'relative-to-absolute-iri';\nimport { ResourceIdentifier } from './identifier/ResourceIdentifier';\nimport type { IQuadTransformer } from './IQuadTransformer';\nimport type { IValueModifier } from './value/IValueModifier';\n\nconst DF = new DataFactory();\n\n/**\n * A quad transformer that matches all resources of the given type,\n * and rewrites its (subject) IRI (across all triples) so that it becomes part of the targeted resource.\n *\n * For example, a transformer matching on type `Post` for identifier predicate `hasId` and target predicate `hasCreator`\n * will modify all post IRIs to become a hash-based IRI inside the object IRI of `hasCreator`.\n * Concretely, `<ex:post1> a <Post>. <ex:post1> <hasId> '1'. <ex:post1> <hasCreator> <urn:person1>`\n * will become\n * `<urn:person1#Post1> a <Post>. <urn:person1#Post1> <hasId> '1'. <urn:person1#post1> <hasCreator> <urn:person1>`.\n *\n * WARNING: This transformer assumes that all the applicable resources\n * have `rdf:type` occurring as first triple with the resource IRI as subject.\n */\nexport class QuadTransformerRemapResourceIdentifier implements IQuadTransformer {\n  private readonly newIdentifierSeparator: string;\n  private readonly identifierPredicate: RegExp;\n  private readonly identifierValueModifier: IValueModifier | undefined;\n  private readonly keepSubjectFragment: boolean;\n  public readonly resourceIdentifier: ResourceIdentifier<RDF.NamedNode>;\n\n  /**\n   * @param newIdentifierSeparator Separator string to use inbetween the target IRI and the identifier value\n   *                               when minting a new resource IRI. This may also be a relative IRI.\n   * @param typeRegex The RDF type that should be used to capture resources.\n   * @param identifierPredicateRegex Predicate regex that contains a resource identifier.\n   * @param targetPredicateRegex Predicate regex that contains an IRI onto which the resource identifier should be\n   *                             remapped.\n   * @param identifierValueModifier An optional value modifier that will be applied on matched identifier values.\n   * @param keepSubjectFragment If the fragment of the original subject should be inherited onto the new identifier IRI.\n   */\n  public constructor(\n    newIdentifierSeparator: string,\n    typeRegex: string,\n    identifierPredicateRegex: string,\n    targetPredicateRegex: string,\n    identifierValueModifier: IValueModifier | undefined,\n    keepSubjectFragment: boolean | undefined,\n  ) {\n    this.newIdentifierSeparator = newIdentifierSeparator;\n    this.identifierPredicate = new RegExp(identifierPredicateRegex, 'u');\n    this.resourceIdentifier = new ResourceIdentifier<RDF.NamedNode>(\n      typeRegex,\n      targetPredicateRegex,\n    );\n    this.identifierValueModifier = identifierValueModifier;\n    this.keepSubjectFragment = Boolean(keepSubjectFragment);\n  }\n\n  public transform(quad: RDF.Quad, allowedComponent?: 'subject' | 'object'): RDF.Quad[] {\n    // If a subject or object in the quad has been remapped (resource has been fully defined before)\n    // Only do this is no components in the quad are being buffered,\n    // otherwise we might lose remapping of quads that are remapped at multiple positions\n    const isBuffered = this.resourceIdentifier.isQuadBuffered(quad, allowedComponent);\n    if (!isBuffered) {\n      const [ modified, mappedQuad ] = this.mapQuad(quad, allowedComponent);\n      if (modified) {\n        return [ mappedQuad ];\n      }\n    }\n\n    // Add buffer entry on applicable resource type\n    if ((!allowedComponent || allowedComponent === 'subject') && this.resourceIdentifier.tryInitializingBuffer(quad)) {\n      // We will emit the quad later\n      return [];\n    }\n\n    // If this resource is buffered\n    if (isBuffered) {\n      const resource = this.resourceIdentifier.getBufferResource(quad);\n\n      // Try to set the id\n      if (this.identifierPredicate.exec(quad.predicate.value)) {\n        if (resource.id) {\n          throw new Error(`Illegal overwrite of identifier value on resource '${quad.subject.value}'`);\n        }\n        resource.id = quad.object;\n\n        // Modify the value if needed\n        if (this.identifierValueModifier) {\n          resource.id = this.identifierValueModifier.apply(resource.id);\n        }\n      }\n\n      // Try to set the target\n      this.resourceIdentifier.tryStoringTarget(resource, quad);\n\n      // Check if resource is complete\n      if (resource.id && resource.target) {\n        // Determine new resource IRI\n        let resourceIri = DF.namedNode(\n          resolve(this.newIdentifierSeparator + resource.id.value, resource.target.value),\n        );\n\n        // Inherit fragment if needed\n        if (this.keepSubjectFragment) {\n          const fragmentPos = quad.subject.value.indexOf('#');\n          if (fragmentPos >= 0) {\n            const fragment = quad.subject.value.slice(fragmentPos);\n            resourceIri = DF.namedNode(resourceIri.value + fragment);\n          }\n        }\n\n        // Clear the buffer, and set rewriting rule\n        this.resourceIdentifier.applyMapping(quad, resourceIri);\n\n        // Flush buffered quads\n        return resource.quads.map(subQuad => this.mapQuad(subQuad, allowedComponent)[1]);\n      }\n\n      // Don't emit anything if our buffer is incomplete\n      return [];\n    }\n\n    return [ quad ];\n  }\n\n  protected mapQuad(quad: RDF.Quad, allowedComponent?: 'subject' | 'object'): [ boolean, RDF.Quad ] {\n    const modified = this.resourceIdentifier.forEachMappedResource(quad, (mapping, component) => {\n      if (component === 'subject' && (!allowedComponent || allowedComponent === 'subject')) {\n        quad = DF.quad(mapping, quad.predicate, quad.object, quad.graph);\n      } else if (!allowedComponent || allowedComponent === 'object') {\n        quad = DF.quad(quad.subject, quad.predicate, mapping, quad.graph);\n      }\n    });\n    return [ modified, quad ];\n  }\n\n  public end(): void {\n    this.resourceIdentifier.onEnd();\n  }\n}\n"]}