{"version":3,"file":"ResourceIdentifier.js","sourceRoot":"","sources":["ResourceIdentifier.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as RDF from '@rdfjs/types';\n\n/**\n * A helper class for tracking resources of a given type.\n *\n * It allows resources of a given type to be mapped to a certain value.\n */\nexport class ResourceIdentifier<T> {\n  private readonly type: RegExp;\n  private readonly targetPredicate: RegExp;\n\n  public readonly buffer: Record<string, IResource>;\n  public readonly resourceMapping: Record<string, T>;\n\n  public constructor(\n    typeRegex: string,\n    targetPredicateRegex: string,\n  ) {\n    this.type = new RegExp(typeRegex, 'u');\n    this.targetPredicate = new RegExp(targetPredicateRegex, 'u');\n\n    this.buffer = {};\n    this.resourceMapping = {};\n  }\n\n  /**\n   * Check if the subject of the given quad occurs within the buffer as a resource.\n   * @param quad A quad\n   * @param allowedComponent The quad component on which transformation is allowed.\n   *                         If undefined, then all components must be considered.\n   */\n  public isQuadBuffered(quad: RDF.Quad, allowedComponent?: 'subject' | 'object'): boolean {\n    return Boolean(((!allowedComponent || allowedComponent === 'subject') &&\n        quad.subject.termType === 'NamedNode' && this.buffer[quad.subject.value]) ||\n      ((!allowedComponent || allowedComponent === 'object') &&\n        quad.object.termType === 'NamedNode' && this.buffer[quad.object.value]));\n  }\n\n  /**\n   * Return the buffer entry for the given subject resource.\n   * @param quad A quad\n   */\n  public getBufferResource(quad: RDF.Quad): IResource {\n    if (quad.subject.termType === 'NamedNode' && this.buffer[quad.subject.value]) {\n      return this.buffer[quad.subject.value];\n    }\n    return this.buffer[quad.object.value];\n  }\n\n  /**\n   * Check if the subject resource is of the expected type, and if so, initialize a buffer entry for it.\n   * @param quad A quad\n   * @return boolean True if the buffer was initialized.\n   */\n  public tryInitializingBuffer(quad: RDF.Quad): boolean {\n    if (quad.subject.termType === 'NamedNode' &&\n      quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' &&\n      quad.object.termType === 'NamedNode' && this.type.exec(quad.object.value)) {\n      this.buffer[quad.subject.value] = { quads: [ quad ], type: quad.object };\n\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * If the quad's predicate matches with the expected predicate, store it within the resource.\n   * @param resource A resource.\n   * @param quad A quad.\n   * @return boolean True if the target was set.\n   */\n  public tryStoringTarget(resource: IResource, quad: RDF.Quad): boolean {\n    // Append the full quad\n    resource.quads.push(quad);\n\n    // Try to set the target\n    if (this.targetPredicate.exec(quad.predicate.value)) {\n      if (quad.object.termType !== 'NamedNode') {\n        throw new Error(`Expected target value of type NamedNode on resource '${quad.subject.value}'`);\n      }\n      if (resource.target) {\n        throw new Error(`Illegal overwrite of target value on resource '${quad.subject.value}'`);\n      }\n      resource.target = quad.object;\n\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * If the subject or object in the given quad was mapped, invoke the given callback for them.\n   * @param quad A quad.\n   * @param callback A callback.\n   * @return boolean True if at least one of the subject or object components were matched.\n   */\n  public forEachMappedResource(\n    quad: RDF.Quad,\n    callback: (mapping: T, component: 'subject' | 'object') => void,\n  ): boolean {\n    let atLeastOne = false;\n    if (quad.subject.termType === 'NamedNode' && this.resourceMapping[quad.subject.value]) {\n      // eslint-disable-next-line callback-return\n      callback(this.resourceMapping[quad.subject.value], 'subject');\n      atLeastOne = true;\n    }\n    if (quad.object.termType === 'NamedNode' && this.resourceMapping[quad.object.value]) {\n      // eslint-disable-next-line callback-return\n      callback(this.resourceMapping[quad.object.value], 'object');\n      atLeastOne = true;\n    }\n    return atLeastOne;\n  }\n\n  /**\n   * Remove the buffer entry for the given resource subject, and store the given mapping for it.\n   * @param quad A quad.\n   * @param mapping A mapping value to set.\n   */\n  public applyMapping(quad: RDF.Quad, mapping: T): void {\n    delete this.buffer[quad.subject.value];\n    this.resourceMapping[quad.subject.value] = mapping;\n  }\n\n  /**\n   * This should be invoked when transformers end.\n   */\n  public onEnd(): void {\n    // After processing is done, check if buffer is clear\n    if (Object.keys(this.buffer).length > 0) {\n      throw new Error(`Detected non-finalized resources in the buffer: ${Object.keys(this.buffer)}`);\n    }\n  }\n}\n\nexport interface IResource {\n  id?: RDF.Term;\n  target?: RDF.NamedNode;\n  quads: RDF.Quad[];\n  type: RDF.NamedNode;\n}\n"]}