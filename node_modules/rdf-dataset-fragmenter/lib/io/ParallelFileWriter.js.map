{"version":3,"file":"ParallelFileWriter.js","sourceRoot":"","sources":["ParallelFileWriter.ts"],"names":[],"mappings":"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","sourcesContent":["import * as fs from 'fs';\nimport { dirname } from 'path';\nimport type { Writable } from 'stream';\nimport { PassThrough } from 'stream';\nimport type * as RDF from '@rdfjs/types';\nimport AsyncLock = require('async-lock');\nimport LRUCache = require('lru-cache');\nimport mkdirp = require('mkdirp');\nimport rdfSerializer from 'rdf-serialize';\n\n/**\n * A parallel file writer enables the writing to an infinite number of files in parallel.\n *\n * It works around system I/O limitations regarding the maximum number of open file descriptors\n * by internally only having a certain number of open file streams,\n * and intelligently closing/re-opening streams when needed using an LRU strategy.\n */\nexport class ParallelFileWriter {\n  private readonly cache: LRUCache<string, IWriteEntry>;\n  private readonly lock: AsyncLock;\n  private fileClosingPromises: Promise<void>[];\n\n  public constructor(options: IParallelFileWriterOptions) {\n    this.cache = new LRUCache({\n      max: options.streams,\n      dispose: (key, value) => this.closeWriteEntry(key, value),\n      noDisposeOnSet: true,\n    });\n    this.lock = new AsyncLock();\n    this.fileClosingPromises = [];\n  }\n\n  /**\n   * Get a write stream that accepts RDF/JS quads for the given file path.\n   * It will automatically be serialized to the RDF format of the given content type.\n   *\n   * The returned stream is only safe to use until another call to this method.\n   *\n   * This is safe with regards to non-existing folders.\n   * If any of the parent folders do not exist, they will be created.\n   *\n   * @param path Path to the file to write to.\n   * @param contentType The content type to serialize for.\n   *                    Note that this only should be content types that enable appending\n   */\n  public async getWriteStream(path: string, contentType: string): Promise<RDF.Stream & Writable> {\n    return this.lock.acquire('getWriteStream', () => this.getWriteStreamUnsafe(path, contentType));\n  }\n\n  protected async getWriteStreamUnsafe(path: string, contentType: string): Promise<RDF.Stream & Writable> {\n    // Try to get the stream from cache, or open a new one if not yet open.\n    let writeEntry = this.cache.get(path);\n    if (!writeEntry) {\n      // Before opening new streams, wait for previous file closings to end\n      await Promise.all(this.fileClosingPromises);\n      this.fileClosingPromises = [];\n\n      // Open the file stream, and prepare the RDF serializer\n      const writeStream: RDF.Stream & Writable = <any> new PassThrough({ objectMode: true });\n      const folder = dirname(path);\n      await mkdirp(folder);\n      const fileStream = fs.createWriteStream(path, { flags: 'a' });\n      rdfSerializer.serialize(writeStream, { contentType }).pipe(fileStream);\n      writeEntry = { writeStream, fileStream };\n      this.cache.set(path, writeEntry);\n    }\n    return writeEntry.writeStream;\n  }\n\n  /**\n   * Close all open streams.\n   */\n  public async close(): Promise<void> {\n    // Add listeners to be able to await stream closing\n    const outputStreamPromises = this.cache.keys()\n      .map(key => this.cache.get(key)!.fileStream)\n      .map(fileStream => new Promise((resolve, reject) => {\n        fileStream.on('finish', resolve);\n        fileStream.on('error', reject);\n      }));\n\n    // Close all output streams\n    this.cache.forEach(writeEntry => writeEntry.writeStream.end());\n\n    // Wait for all streams to close\n    await Promise.all(outputStreamPromises);\n  }\n\n  protected closeWriteEntry(path: string, writeEntry: IWriteEntry): void {\n    this.fileClosingPromises.push(new Promise((resolve, reject) => {\n      writeEntry.fileStream.on('finish', resolve);\n      writeEntry.fileStream.on('error', reject);\n    }));\n    writeEntry.writeStream.end();\n  }\n}\n\nexport interface IWriteEntry {\n  writeStream: RDF.Stream & Writable;\n  fileStream: fs.WriteStream;\n}\n\nexport interface IParallelFileWriterOptions {\n  streams: number;\n}\n"]}