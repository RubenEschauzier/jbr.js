{"version":3,"file":"Fragmenter.js","sourceRoot":"","sources":["Fragmenter.ts"],"names":[],"mappings":";;;;;;;;;;;;AAMA,yEAAsE;AAEtE;;GAEG;AACH,MAAa,UAAU;IAMrB,YAAmB,OAA2B;QAC5C,IAAI,CAAC,UAAU,GAAG,OAAO,CAAC,UAAU,CAAC;QACrC,IAAI,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY,CAAC;QACzC,IAAI,CAAC,qBAAqB,GAAG,OAAO,CAAC,qBAAqB,CAAC;QAC3D,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC;IACnC,CAAC;IAEM,MAAM,CAAC,wBAAwB,CACpC,UAAuB,EACvB,YAAgC;QAEhC,MAAM,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,CAAC;QACzC,IAAI,YAAY,CAAC,MAAM,GAAG,CAAC,EAAE;YAC3B,MAAM,qBAAqB,GAAG,IAAI,yCAAmB,CAAC,YAAY,CAAC,CAAC;YACpE,UAAU,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,EAAE,CAAC,qBAAqB,CAAC,IAAI,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,CAAC;YACrF,UAAU,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YACvC,OAAO,qBAAqB,CAAC;SAC9B;QACD,OAAO,UAAU,CAAC;IACpB,CAAC;IAED;;OAEG;IACU,QAAQ;;YACnB,MAAM,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CACvC,UAAU,CAAC,wBAAwB,CAAC,IAAI,CAAC,UAAU,EAAE,IAAI,CAAC,YAAY,IAAI,EAAE,CAAC,EAC7E,IAAI,CAAC,QAAQ,CACd,CAAC;YACF,MAAM,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;QAC9B,CAAC;KAAA;CACF;AArCD,gCAqCC","sourcesContent":["import type { Readable } from 'stream';\nimport type * as RDF from '@rdfjs/types';\nimport type { IQuadSink } from './io/IQuadSink';\nimport type { IQuadSource } from './io/IQuadSource';\nimport type { IFragmentationStrategy } from './strategy/IFragmentationStrategy';\nimport type { IQuadTransformer } from './transform/IQuadTransformer';\nimport { QuadTransformStream } from './transform/QuadTransformStream';\n\n/**\n * Fragments quads from a given source into a given sink.\n */\nexport class Fragmenter {\n  private readonly quadSource: IQuadSource;\n  private readonly transformers?: IQuadTransformer[];\n  private readonly fragmentationStrategy: IFragmentationStrategy;\n  private readonly quadSink: IQuadSink;\n\n  public constructor(options: IFragmenterOptions) {\n    this.quadSource = options.quadSource;\n    this.transformers = options.transformers;\n    this.fragmentationStrategy = options.fragmentationStrategy;\n    this.quadSink = options.quadSink;\n  }\n\n  public static getTransformedQuadStream(\n    quadSource: IQuadSource,\n    transformers: IQuadTransformer[],\n  ): RDF.Stream & Readable {\n    const quadStream = quadSource.getQuads();\n    if (transformers.length > 0) {\n      const transformedQuadStream = new QuadTransformStream(transformers);\n      quadStream.on('error', (error: Error) => transformedQuadStream.emit('error', error));\n      quadStream.pipe(transformedQuadStream);\n      return transformedQuadStream;\n    }\n    return quadStream;\n  }\n\n  /**\n   * Read quads from a given source, fragment it into the sink, and close the sink.\n   */\n  public async fragment(): Promise<void> {\n    await this.fragmentationStrategy.fragment(\n      Fragmenter.getTransformedQuadStream(this.quadSource, this.transformers || []),\n      this.quadSink,\n    );\n    await this.quadSink.close();\n  }\n}\n\nexport interface IFragmenterOptions {\n  quadSource: IQuadSource;\n  transformers?: IQuadTransformer[];\n  fragmentationStrategy: IFragmentationStrategy;\n  quadSink: IQuadSink;\n}\n"]}