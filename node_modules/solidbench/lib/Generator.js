"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = void 0;
const fs = __importStar(require("fs"));
const https_1 = require("https");
const Path = __importStar(require("path"));
const dockerode_1 = __importDefault(require("dockerode"));
const ldbc_snb_enhancer_1 = require("ldbc-snb-enhancer");
const ldbc_snb_validation_generator_1 = require("ldbc-snb-validation-generator");
const rdf_dataset_fragmenter_1 = require("rdf-dataset-fragmenter");
const sparql_query_parameter_instantiator_1 = require("sparql-query-parameter-instantiator");
const unzipper_1 = require("unzipper");
/**
 * Generates decentralized social network data in different phases.
 */
class Generator {
    constructor(opts) {
        this.cwd = opts.cwd;
        this.verbose = opts.verbose;
        this.overwrite = opts.overwrite;
        this.scale = opts.scale;
        this.enhancementConfig = opts.enhancementConfig;
        this.fragmentConfig = opts.fragmentConfig;
        this.enhancementFragmentConfig = opts.enhancementFragmentConfig;
        this.queryConfig = opts.queryConfig;
        this.validationParams = opts.validationParams;
        this.validationConfig = opts.validationConfig;
        this.hadoopMemory = opts.hadoopMemory;
        this.mainModulePath = Path.join(__dirname, '..');
    }
    targetExists(path) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield fs.promises.stat(path);
                return true;
            }
            catch (_a) {
                return false;
            }
        });
    }
    log(phase, status) {
        process.stdout.write(`${Generator.withColor(`[${phase}]`, Generator.COLOR_CYAN)} ${status}\n`);
    }
    runPhase(name, directory, runner) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.overwrite || !(yield this.targetExists(Path.join(this.cwd, directory)))) {
                this.log(name, 'Started');
                const timeStart = process.hrtime();
                yield runner();
                const timeEnd = process.hrtime(timeStart);
                this.log(name, `Done in ${timeEnd[0] + (timeEnd[1] / 1000000000)} seconds`);
            }
            else {
                this.log(name, `Skipped (/${directory} already exists, remove to regenerate)`);
            }
        });
    }
    /**
     * Run all generator phases.
     */
    generate() {
        return __awaiter(this, void 0, void 0, function* () {
            const timeStart = process.hrtime();
            yield this.runPhase('SNB dataset generator', 'out-snb', () => this.generateSnbDataset());
            yield this.runPhase('SNB dataset enhancer', 'out-enhanced', () => this.enhanceSnbDataset());
            yield this.runPhase('SNB dataset fragmenter', 'out-fragments', () => this.fragmentSnbDataset());
            yield this.runPhase('SPARQL query instantiator', 'out-queries', () => this.instantiateQueries());
            yield this.runPhase('SNB validation downloader', 'out-validate-params', () => this.downloadValidationParams());
            yield this.runPhase('SNB validation generator', 'out-validate', () => this.generateValidation());
            const timeEnd = process.hrtime(timeStart);
            this.log('All', `Done in ${timeEnd[0] + (timeEnd[1] / 1000000000)} seconds`);
        });
    }
    /**
     * Invoke the LDBC SNB generator.
     */
    generateSnbDataset() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create params.ini file
            const paramsTemplate = yield fs.promises.readFile(Path.join(__dirname, '../templates/params.ini'), 'utf8');
            const paramsPath = Path.join(this.cwd, 'params.ini');
            // TODO: remove once we drop Node 14 support
            // eslint-disable-next-line unicorn/prefer-string-replace-all
            yield fs.promises.writeFile(paramsPath, paramsTemplate.replace(/SCALE/ug, this.scale), 'utf8');
            // Pull the base Docker image
            const dockerode = new dockerode_1.default();
            const buildStream = yield dockerode.pull(Generator.LDBC_SNB_DATAGEN_DOCKER_IMAGE);
            yield new Promise((resolve, reject) => {
                dockerode.modem.followProgress(buildStream, (err, res) => err ? reject(err) : resolve(res));
            });
            // Start Docker container
            const container = yield dockerode.createContainer({
                Image: Generator.LDBC_SNB_DATAGEN_DOCKER_IMAGE,
                Tty: true,
                AttachStdout: true,
                AttachStderr: true,
                Env: [`HADOOP_CLIENT_OPTS=-Xmx${this.hadoopMemory}`],
                HostConfig: {
                    Binds: [
                        `${this.cwd}/out-snb/:/opt/ldbc_snb_datagen/out`,
                        `${paramsPath}:/opt/ldbc_snb_datagen/params.ini`,
                    ],
                },
            });
            yield container.start();
            // Stop process on force-exit
            let containerEnded = false;
            process.on('SIGINT', () => __awaiter(this, void 0, void 0, function* () {
                if (!containerEnded) {
                    yield container.kill();
                    yield cleanup();
                }
            }));
            function cleanup() {
                return __awaiter(this, void 0, void 0, function* () {
                    yield container.remove();
                    yield fs.promises.unlink(paramsPath);
                });
            }
            // Attach output to stdout
            const out = yield container.attach({
                stream: true,
                stdout: true,
                stderr: true,
            });
            if (this.verbose) {
                out.pipe(process.stdout);
            }
            else {
                out.resume();
            }
            // Wait until generation ends
            yield new Promise((resolve, reject) => {
                out.on('end', resolve);
                out.on('error', reject);
            });
            containerEnded = true;
            // Cleanup
            yield cleanup();
        });
    }
    /**
     * Enhance the generated LDBC SNB dataset.
     */
    enhanceSnbDataset() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create target directory
            yield fs.promises.mkdir(Path.join(this.cwd, 'out-enhanced'));
            // Run enhancer
            const oldCwd = process.cwd();
            process.chdir(this.cwd);
            yield (0, ldbc_snb_enhancer_1.runConfig)(this.enhancementConfig, { mainModulePath: this.mainModulePath });
            process.chdir(oldCwd);
        });
    }
    /**
     * Fragment the generated and enhanced LDBC SNB datasets.
     */
    fragmentSnbDataset() {
        return __awaiter(this, void 0, void 0, function* () {
            const oldCwd = process.cwd();
            process.chdir(this.cwd);
            // Initial fragmentation
            yield (0, rdf_dataset_fragmenter_1.runConfig)(this.fragmentConfig, { mainModulePath: this.mainModulePath });
            // Auxiliary fragmentation
            this.log('SNB dataset fragmenter', 'Starting auxiliary phase');
            yield (0, rdf_dataset_fragmenter_1.runConfig)(this.enhancementFragmentConfig, { mainModulePath: this.mainModulePath });
            process.chdir(oldCwd);
        });
    }
    /**
     * Instantiate queries based on the LDBC SNB datasets.
     */
    instantiateQueries() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create target directory
            yield fs.promises.mkdir(Path.join(this.cwd, 'out-queries'));
            // Run instantiator
            const oldCwd = process.cwd();
            process.chdir(this.cwd);
            yield (0, sparql_query_parameter_instantiator_1.runConfig)(this.queryConfig, { mainModulePath: this.mainModulePath }, {
                variables: yield this.generateVariables(),
            });
            process.chdir(oldCwd);
        });
    }
    /**
     * Download validation parameters
     */
    downloadValidationParams() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create target directory
            const target = Path.join(this.cwd, 'out-validate-params');
            yield fs.promises.mkdir(target);
            // Download and extract zip file
            return new Promise((resolve, reject) => {
                (0, https_1.request)(this.validationParams, res => {
                    res
                        .on('error', reject)
                        .pipe((0, unzipper_1.Extract)({ path: target }))
                        .on('error', reject)
                        .on('close', resolve);
                }).end();
            });
        });
    }
    /**
     * Generate validation queries and results.
     */
    generateValidation() {
        return __awaiter(this, void 0, void 0, function* () {
            // Create target directory
            yield fs.promises.mkdir(Path.join(this.cwd, 'out-validate'));
            // Run generator
            const oldCwd = process.cwd();
            process.chdir(this.cwd);
            yield (0, ldbc_snb_validation_generator_1.runConfig)(this.validationConfig, { mainModulePath: this.mainModulePath }, {
                variables: yield this.generateVariables(),
            });
            process.chdir(oldCwd);
        });
    }
    generateVariables() {
        return __awaiter(this, void 0, void 0, function* () {
            return Object.fromEntries((yield fs.promises.readdir(Path.join(__dirname, '../templates/queries/')))
                .map(name => [`urn:variables:query-templates:${name}`, Path.join(__dirname, `../templates/queries/${name}`)]));
        });
    }
    /**
     * Return a string in a given color
     * @param str The string that should be printed in
     * @param color A given color
     */
    static withColor(str, color) {
        return `${color}${str}${Generator.COLOR_RESET}`;
    }
}
exports.Generator = Generator;
Generator.COLOR_RESET = '\u001B[0m';
Generator.COLOR_RED = '\u001B[31m';
Generator.COLOR_GREEN = '\u001B[32m';
Generator.COLOR_YELLOW = '\u001B[33m';
Generator.COLOR_BLUE = '\u001B[34m';
Generator.COLOR_MAGENTA = '\u001B[35m';
Generator.COLOR_CYAN = '\u001B[36m';
Generator.COLOR_GRAY = '\u001B[90m';
Generator.LDBC_SNB_DATAGEN_DOCKER_IMAGE = 'rubensworks/ldbc_snb_datagen:latest';
//# sourceMappingURL=Generator.js.map