"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Enhancer = void 0;
const fs = require("fs");
const stream_1 = require("stream");
const rdf_data_factory_1 = require("rdf-data-factory");
const rdf_object_1 = require("rdf-object");
const rdf_parse_1 = require("rdf-parse");
const rdf_serialize_1 = require("rdf-serialize");
const DF = new rdf_data_factory_1.DataFactory();
/**
 * Enhances a given dataset.
 */
class Enhancer {
    constructor(options) {
        var _a, _b;
        this.personsPath = options.personsPath;
        this.activitiesPath = options.activitiesPath;
        this.staticPath = options.staticPath;
        this.destinationPathData = options.destinationPathData;
        this.dataSelector = options.dataSelector;
        this.handlers = options.handlers || [];
        this.logger = options.logger;
        this.parameterEmitterPosts = options.parameterEmitterPosts;
        this.parameterEmitterComments = options.parameterEmitterComments;
        this.rdfObjectLoader = new rdf_object_1.RdfObjectLoader({ context: Enhancer.CONTEXT_LDBC_SNB });
        (_a = this.parameterEmitterPosts) === null || _a === void 0 ? void 0 : _a.emitHeader(['post']);
        (_b = this.parameterEmitterComments) === null || _b === void 0 ? void 0 : _b.emitHeader(['comment']);
    }
    /**
     * Generates an auxiliary dataset.
     */
    generate() {
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            // Make sure our object loader is initialized
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.log('Loading context');
            yield this.rdfObjectLoader.context;
            // Prepare output stream
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.log('Preparing output stream');
            const writeStream = new stream_1.PassThrough({ objectMode: true });
            const fileStream = fs.createWriteStream(this.destinationPathData);
            rdf_serialize_1.default.serialize(writeStream, { contentType: 'text/turtle' }).pipe(fileStream);
            // Prepare context
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.log('Reading background data: people');
            const { people, peopleLocatedInCities, peopleKnows, peopleKnownBy, predicates, personClasses, } = yield this.extractPeople();
            (_d = this.logger) === null || _d === void 0 ? void 0 : _d.log('Reading background data: activities');
            const { posts, postsDetails, comments, activityClasses } = yield this.extractActivities();
            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.log('Reading background data: cities');
            const cities = yield this.extractCities();
            const classes = personClasses.concat(activityClasses);
            const context = {
                rdfObjectLoader: this.rdfObjectLoader,
                dataSelector: this.dataSelector,
                people,
                peopleLocatedInCities,
                peopleKnows,
                peopleKnownBy,
                posts,
                postsDetails,
                comments,
                cities,
                predicates,
                classes,
            };
            // Generate data
            for (const handler of this.handlers) {
                (_f = this.logger) === null || _f === void 0 ? void 0 : _f.log(`Running ${handler.constructor.name}`);
                yield handler.generate(writeStream, context);
            }
            // Close output stream
            (_g = this.logger) === null || _g === void 0 ? void 0 : _g.log('Ending');
            writeStream.end();
        });
    }
    extractPeople() {
        return new Promise((resolve, reject) => {
            // Prepare RDF terms to compare with
            const termType = this.rdfObjectLoader.createCompactedResource('rdf:type').term;
            const termPerson = this.rdfObjectLoader.createCompactedResource('snvoc:Person').term;
            const termIsLocatedIn = this.rdfObjectLoader.createCompactedResource('snvoc:isLocatedIn').term;
            const termKnows = this.rdfObjectLoader.createCompactedResource('snvoc:knows').term;
            const termHasPerson = this.rdfObjectLoader.createCompactedResource('snvoc:hasPerson').term;
            const people = [];
            const peopleLocatedInCities = {};
            const peopleKnows = {};
            const peopleKnownBy = {};
            const predicates = new Set();
            const classes = new Set();
            const stream = rdf_parse_1.default.parse(fs.createReadStream(this.personsPath), { path: this.personsPath });
            // Temporary variables to determine knows relationships
            let currentKnowsPerson;
            let currentKnowsNode;
            stream.on('error', reject);
            stream.on('data', (quad) => {
                // Extract people
                if (quad.subject.termType === 'NamedNode' &&
                    quad.predicate.equals(termType) &&
                    quad.object.equals(termPerson)) {
                    people.push(quad.subject);
                }
                // Extract people located in cities
                if (quad.subject.termType === 'NamedNode' &&
                    quad.predicate.equals(termIsLocatedIn) &&
                    quad.object.termType === 'NamedNode') {
                    peopleLocatedInCities[quad.subject.value] = quad.object;
                }
                // Extract people knows relationships
                // 1. Determine reified blank node identifying the relationships
                if (quad.subject.termType === 'NamedNode' &&
                    quad.predicate.equals(termKnows) &&
                    quad.object.termType === 'BlankNode') {
                    currentKnowsPerson = quad.subject;
                    currentKnowsNode = quad.object;
                }
                // 2. Determine the person linked to the relationships
                if (currentKnowsPerson &&
                    quad.subject.equals(currentKnowsNode) &&
                    quad.predicate.equals(termHasPerson) &&
                    quad.object.termType === 'NamedNode') {
                    if (!peopleKnows[currentKnowsPerson.value]) {
                        peopleKnows[currentKnowsPerson.value] = [];
                    }
                    if (!peopleKnownBy[quad.object.value]) {
                        peopleKnownBy[quad.object.value] = [];
                    }
                    peopleKnows[currentKnowsPerson.value].push(quad.object);
                    peopleKnownBy[quad.object.value].push(currentKnowsPerson);
                    currentKnowsPerson = undefined;
                    currentKnowsNode = undefined;
                }
                // Determine predicates
                predicates.add(quad.predicate.value);
                // Determine classes
                if (quad.predicate.equals(termType)) {
                    classes.add(quad.object.value);
                }
            });
            stream.on('end', () => {
                resolve({
                    people,
                    peopleLocatedInCities,
                    peopleKnows,
                    peopleKnownBy,
                    predicates: [...predicates].map(value => DF.namedNode(value)),
                    personClasses: [...classes].map(value => DF.namedNode(value)),
                });
            });
        });
    }
    extractActivities() {
        return new Promise((resolve, reject) => {
            // Prepare RDF terms to compare with
            const termType = this.rdfObjectLoader.createCompactedResource('rdf:type').term;
            const termPost = this.rdfObjectLoader.createCompactedResource('snvoc:Post').term;
            const termComment = this.rdfObjectLoader.createCompactedResource('snvoc:Comment').term;
            const posts = [];
            const postsDetails = {};
            const comments = [];
            const stream = rdf_parse_1.default.parse(fs.createReadStream(this.activitiesPath), { path: this.activitiesPath });
            stream.on('error', reject);
            stream.on('data', (quad) => {
                var _a, _b;
                if (quad.subject.termType === 'NamedNode' &&
                    quad.predicate.equals(termType)) {
                    if (quad.object.equals(termPost)) {
                        posts.push(quad.subject);
                        // Emit parameters
                        (_a = this.parameterEmitterPosts) === null || _a === void 0 ? void 0 : _a.emitRow([quad.subject.value]);
                        postsDetails[quad.subject.value] = [];
                    }
                    if (quad.object.equals(termComment)) {
                        comments.push(quad.subject);
                        (_b = this.parameterEmitterComments) === null || _b === void 0 ? void 0 : _b.emitRow([quad.subject.value]);
                    }
                }
                if (quad.subject.termType === 'NamedNode') {
                    const postDetails = postsDetails[quad.subject.value];
                    if (postDetails) {
                        postDetails.push(quad);
                    }
                }
            });
            stream.on('end', () => {
                var _a, _b;
                (_a = this.parameterEmitterPosts) === null || _a === void 0 ? void 0 : _a.flush();
                (_b = this.parameterEmitterComments) === null || _b === void 0 ? void 0 : _b.flush();
                resolve({
                    posts,
                    postsDetails,
                    comments,
                    activityClasses: [DF.namedNode(termPost.value), DF.namedNode(termComment.value)],
                });
            });
        });
    }
    extractCities() {
        return new Promise((resolve, reject) => {
            // Prepare RDF terms to compare with
            const termType = this.rdfObjectLoader.createCompactedResource('rdf:type').term;
            const termCity = this.rdfObjectLoader.createCompactedResource('dbpedia-owl:City').term;
            const posts = [];
            const stream = rdf_parse_1.default.parse(fs.createReadStream(this.staticPath), { path: this.staticPath });
            stream.on('error', reject);
            stream.on('data', (quad) => {
                if (quad.subject.termType === 'NamedNode' &&
                    quad.predicate.equals(termType) &&
                    quad.object.equals(termCity)) {
                    posts.push(quad.subject);
                }
            });
            stream.on('end', () => {
                resolve(posts);
            });
        });
    }
}
exports.Enhancer = Enhancer;
Enhancer.CONTEXT_LDBC_SNB = require('./context-ldbc-snb.json');
//# sourceMappingURL=Enhancer.js.map