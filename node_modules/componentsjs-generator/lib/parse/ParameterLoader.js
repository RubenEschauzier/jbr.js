"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterLoader = void 0;
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const TypeReferenceOverrideAliasRecord_1 = require("./typereferenceoverride/TypeReferenceOverrideAliasRecord");
/**
 * Interprets class parameters of a given class.
 */
class ParameterLoader {
    constructor(args) {
        this.commentLoader = args.commentLoader;
        this.hardErrorUnsupported = args.hardErrorUnsupported;
        this.logger = args.logger;
    }
    /**
     * Create a class index containing all constructor data from the classes in the given index.
     * @param classIndex An index of loaded classes.
     */
    loadAllExtensionData(classIndex) {
        const newIndex = {};
        for (const [key, classLoaded] of Object.entries(classIndex)) {
            if (classLoaded.type === 'class' || classLoaded.type === 'interface') {
                newIndex[key] = this.loadExtensionData(classLoaded);
            }
        }
        return newIndex;
    }
    /**
     * Load the extension data of the given class or interface.
     * @param classReference A loaded class or interface reference.
     */
    loadExtensionData(classReference) {
        const extensionDatas = [];
        if (classReference.type === 'class') {
            if (classReference.superClass) {
                extensionDatas.push({
                    classLoaded: classReference.superClass.value,
                    genericTypeInstantiations: classReference.superClass.genericTypeInstantiations ?
                        this.getGenericTypeParameterInstantiations(classReference.superClass.genericTypeInstantiations, classReference) :
                        [],
                });
            }
            if (classReference.implementsInterfaces) {
                for (const iface of classReference.implementsInterfaces) {
                    extensionDatas.push({
                        classLoaded: iface.value,
                        genericTypeInstantiations: iface.genericTypeInstantiations ?
                            this.getGenericTypeParameterInstantiations(iface.genericTypeInstantiations, classReference) :
                            [],
                    });
                }
            }
        }
        else if (classReference.superInterfaces) {
            for (const iface of classReference.superInterfaces) {
                extensionDatas.push({
                    classLoaded: iface.value,
                    genericTypeInstantiations: iface.genericTypeInstantiations ?
                        this.getGenericTypeParameterInstantiations(iface.genericTypeInstantiations, classReference) :
                        [],
                });
            }
        }
        return extensionDatas;
    }
    /**
     * Load all parameter data from all fields in the given constructor inheritance chain.
     * @param constructorChain An array of constructors within the class inheritance chain.
     */
    loadConstructorFields(constructorChain) {
        const classLoaded = constructorChain[0].classLoaded.value;
        // Load the constructor comment
        const constructorCommentData = this.commentLoader.getCommentDataFromConstructor(constructorChain);
        // Load all constructor parameters
        const parameters = [];
        for (const field of constructorChain[0].constructor.value.params) {
            this.loadConstructorField(classLoaded, parameters, constructorCommentData, field);
        }
        return {
            parameters,
            classLoaded,
        };
    }
    /**
     * Load generics types from the given class.
     * @param classLoaded A loaded class.
     */
    loadClassGenerics(classLoaded) {
        // Load all generic type parameters
        const genericTypeParameters = [];
        for (const [genericName, genericType] of Object.entries(classLoaded.generics)) {
            this.loadClassGeneric(classLoaded, genericTypeParameters, genericName, genericType.type);
        }
        return {
            genericTypeParameters,
            classLoaded,
        };
    }
    /**
     * Load the generic type parameter data from the given generic in a class.
     * @param classLoaded The loaded class in which the field is defined.
     * @param genericTypeParameters The array of generic type parameters that will be appended to.
     * @param genericName The generic type name.
     * @param genericType The optional generic type range.
     */
    loadClassGeneric(classLoaded, genericTypeParameters, genericName, genericType) {
        genericTypeParameters.push({
            name: genericName,
            ...genericType ?
                { range: this.getRangeFromTypeNode(classLoaded, genericType, this.getErrorIdentifierGeneric(classLoaded, genericName)) } :
                {},
        });
    }
    /**
     * Load the parameter data from the given field in a constructor.
     * @param classLoaded The loaded class in which the field is defined.
     * @param parameters The array of parameters that will be appended to.
     * @param constructorCommentData Comment data from the constructor.
     * @param field The field to load.
     */
    loadConstructorField(classLoaded, parameters, constructorCommentData, field) {
        if (field.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
            const commentData = constructorCommentData[field.name] || {};
            if (!commentData.ignored) {
                parameters.push(this.loadField(classLoaded, field, commentData));
            }
        }
        else if (field.type === typescript_estree_1.AST_NODE_TYPES.TSParameterProperty) {
            this.loadConstructorField(classLoaded, parameters, constructorCommentData, field.parameter);
        }
        else {
            this.throwOrWarn(new Error(`Could not understand constructor parameter type ${field.type} in ${classLoaded.localName} at ${classLoaded.fileName}`));
        }
    }
    /**
     * Load all parameter data from all fields in the given interface.
     * If methods are found in the interface, an error is thrown.
     * @param iface An interface
     */
    loadInterfaceFields(iface) {
        let fields = iface
            .declaration.body.body
            .map(field => this.loadTypeElementField(iface, field))
            .filter(Boolean);
        if (iface.superInterfaces && iface.superInterfaces.length > 0) {
            // TODO: pass down superIface.genericTypeInstantiations to loadInterfaceFields
            fields = fields.concat(...iface.superInterfaces.map(superIface => this.loadInterfaceFields(superIface.value)));
        }
        return fields;
    }
    /**
     * Load all parameter data from all fields in the given hash.
     * @param classLoaded The loaded class in which the field is defined.
     * @param hash An hash element.
     */
    loadHashFields(classLoaded, hash) {
        return hash.members
            .map(field => this.loadTypeElementField(classLoaded, field))
            .filter(Boolean);
    }
    /**
     * Load the parameter data from the given type element.
     * @param classLoaded The loaded class in which the field is defined.
     * @param typeElement A type element, such as an interface or hash field.
     */
    loadTypeElementField(classLoaded, typeElement) {
        let commentData;
        switch (typeElement.type) {
            case typescript_estree_1.AST_NODE_TYPES.TSPropertySignature:
                commentData = this.commentLoader.getCommentDataFromField(classLoaded, typeElement);
                if (!commentData.ignored) {
                    return this.loadField(classLoaded, typeElement, commentData);
                }
                return;
            case typescript_estree_1.AST_NODE_TYPES.TSIndexSignature:
                commentData = this.commentLoader.getCommentDataFromField(classLoaded, typeElement);
                if (!commentData.ignored) {
                    return this.loadIndex(classLoaded, typeElement, commentData);
                }
                return;
            default:
                this.throwOrWarn(new Error(`Unsupported field type ${typeElement.type} in ${classLoaded.localName} in ${classLoaded.fileName}`));
        }
    }
    /**
     * Load the parameter data from the given field.
     * @param classLoaded The loaded class in which the field is defined.
     * @param field A field.
     * @param commentData Comment data about the given field.
     */
    loadField(classLoaded, field, commentData) {
        // Required data
        const parameterData = {
            type: 'field',
            name: this.getFieldName(classLoaded, field),
            range: this.getFieldRange(classLoaded, field, commentData),
            defaults: commentData.defaults,
            defaultNested: commentData.defaultNested,
        };
        const comment = this.getFieldComment(commentData);
        if (comment) {
            parameterData.comment = comment;
        }
        return parameterData;
    }
    getFieldName(classLoaded, field) {
        if ('name' in field) {
            // If Identifier
            return field.name;
        }
        // Else TSPropertySignature
        if (field.key.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
            return field.key.name;
        }
        throw new Error(`Unsupported field key type ${field.key.type} in interface ${classLoaded.localName} in ${classLoaded.fileName}`);
    }
    getErrorIdentifierGeneric(classLoaded, genericName) {
        return `generic type ${genericName}`;
    }
    getErrorIdentifierField(classLoaded, field) {
        return `field ${this.getFieldName(classLoaded, field)}`;
    }
    getErrorIdentifierIndex() {
        return `an index signature`;
    }
    getRangeFromTypeNode(classLoaded, typeNode, errorIdentifier) {
        let typeAliasOverride;
        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check
        switch (typeNode.type) {
            case typescript_estree_1.AST_NODE_TYPES.TSTypeReference:
                if (typeNode.typeName.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
                    // TS raw types can also start with an uppercase
                    switch (typeNode.typeName.name) {
                        case 'Boolean':
                            return { type: 'raw', value: 'boolean' };
                        case 'Number':
                            return { type: 'raw', value: 'number' };
                        case 'String':
                            return { type: 'raw', value: 'string' };
                        case 'Array':
                            if (typeNode.typeParameters && typeNode.typeParameters.params.length === 1) {
                                return {
                                    type: 'array',
                                    value: this.getRangeFromTypeNode(classLoaded, typeNode.typeParameters.params[0], errorIdentifier),
                                };
                            }
                            this.throwOrWarn(new Error(`Found invalid Array field type at ${errorIdentifier} in ${classLoaded.localName} at ${classLoaded.fileName}`));
                            return { type: 'wildcard' };
                        default:
                            // First check if the type is a direct generic type
                            if (classLoaded.type !== 'enum' && typeNode.typeName.name in classLoaded.generics) {
                                return {
                                    type: 'genericTypeReference',
                                    value: typeNode.typeName.name,
                                };
                            }
                            // Check if this node is a predefined type alias
                            typeAliasOverride = this.handleTypeOverride(typeNode);
                            if (typeAliasOverride) {
                                return typeAliasOverride;
                            }
                            // Otherwise, assume we have an interface/class parameter
                            return {
                                type: 'interface',
                                value: typeNode.typeName.name,
                                genericTypeParameterInstantiations: typeNode.typeParameters ?
                                    this.getGenericTypeParameterInstantiations(typeNode.typeParameters, classLoaded) :
                                    undefined,
                                origin: classLoaded,
                            };
                    }
                }
                else {
                    // Otherwise we have a qualified name: AST_NODE_TYPES.TSQualifiedName
                    return {
                        type: 'interface',
                        value: typeNode.typeName.right.name,
                        qualifiedPath: this.getQualifiedPath(typeNode.typeName.left),
                        genericTypeParameterInstantiations: typeNode.typeParameters ?
                            this.getGenericTypeParameterInstantiations(typeNode.typeParameters, classLoaded) :
                            undefined,
                        origin: classLoaded,
                    };
                }
            case typescript_estree_1.AST_NODE_TYPES.TSBooleanKeyword:
                return { type: 'raw', value: 'boolean' };
            case typescript_estree_1.AST_NODE_TYPES.TSNumberKeyword:
                return { type: 'raw', value: 'number' };
            case typescript_estree_1.AST_NODE_TYPES.TSStringKeyword:
                return { type: 'raw', value: 'string' };
            case typescript_estree_1.AST_NODE_TYPES.TSLiteralType:
                if (typeNode.literal.type !== typescript_estree_1.AST_NODE_TYPES.UnaryExpression &&
                    typeNode.literal.type !== typescript_estree_1.AST_NODE_TYPES.UpdateExpression &&
                    'value' in typeNode.literal &&
                    (typeof typeNode.literal.value === 'number' ||
                        typeof typeNode.literal.value === 'string' ||
                        typeof typeNode.literal.value === 'boolean')) {
                    return { type: 'literal', value: typeNode.literal.value };
                }
                break;
            case typescript_estree_1.AST_NODE_TYPES.TSTypeLiteral:
                return { type: 'hash', value: typeNode };
            case typescript_estree_1.AST_NODE_TYPES.TSUnionType:
            case typescript_estree_1.AST_NODE_TYPES.TSIntersectionType:
                return {
                    type: typeNode.type === typescript_estree_1.AST_NODE_TYPES.TSUnionType ? 'union' : 'intersection',
                    elements: typeNode.types
                        .map(type => this.getRangeFromTypeNode(classLoaded, type, errorIdentifier)),
                };
            case typescript_estree_1.AST_NODE_TYPES.TSUndefinedKeyword:
                return { type: 'undefined' };
            case typescript_estree_1.AST_NODE_TYPES.TSUnknownKeyword:
            case typescript_estree_1.AST_NODE_TYPES.TSVoidKeyword:
            case typescript_estree_1.AST_NODE_TYPES.TSNullKeyword:
            case typescript_estree_1.AST_NODE_TYPES.TSAnyKeyword:
                return { type: 'wildcard' };
            case typescript_estree_1.AST_NODE_TYPES.TSFunctionType:
            case typescript_estree_1.AST_NODE_TYPES.TSImportType:
            case typescript_estree_1.AST_NODE_TYPES.TSMappedType:
            case typescript_estree_1.AST_NODE_TYPES.TSNeverKeyword:
                // TODO: These types are explicitly not supported at the moment
                return { type: 'wildcard' };
            case typescript_estree_1.AST_NODE_TYPES.TSTupleType:
                return {
                    type: 'tuple',
                    elements: typeNode.elementTypes
                        .map(type => this.getRangeFromTypeNode(classLoaded, type, errorIdentifier)),
                };
            case typescript_estree_1.AST_NODE_TYPES.TSArrayType:
                return {
                    type: 'array',
                    value: this.getRangeFromTypeNode(classLoaded, typeNode.elementType, errorIdentifier),
                };
            case typescript_estree_1.AST_NODE_TYPES.TSRestType:
                return {
                    type: 'rest',
                    value: this.getRangeFromTypeNode(classLoaded, typeNode.typeAnnotation, errorIdentifier),
                };
            case typescript_estree_1.AST_NODE_TYPES.TSTypeOperator:
                if (typeNode.operator === 'keyof' && typeNode.typeAnnotation) {
                    return {
                        type: 'keyof',
                        value: this.getRangeFromTypeNode(classLoaded, typeNode.typeAnnotation, errorIdentifier),
                    };
                }
                break;
            case typescript_estree_1.AST_NODE_TYPES.TSTypeQuery:
                if (typeNode.exprName.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
                    return {
                        type: 'typeof',
                        value: typeNode.exprName.name,
                        origin: classLoaded,
                    };
                }
                // Otherwise we have a qualified name: AST_NODE_TYPES.TSQualifiedName
                return {
                    type: 'typeof',
                    value: typeNode.exprName.right.name,
                    qualifiedPath: this.getQualifiedPath(typeNode.exprName.left),
                    origin: classLoaded,
                };
            case typescript_estree_1.AST_NODE_TYPES.TSIndexedAccessType:
                return {
                    type: 'indexed',
                    object: this.getRangeFromTypeNode(classLoaded, typeNode.objectType, errorIdentifier),
                    index: this.getRangeFromTypeNode(classLoaded, typeNode.indexType, errorIdentifier),
                };
        }
        this.throwOrWarn(new Error(`Could not understand parameter type ${typeNode.type} of ${errorIdentifier} in ${classLoaded.localName} at ${classLoaded.fileName}`));
        return { type: 'wildcard' };
    }
    getGenericTypeParameterInstantiations(typeParameters, classLoaded) {
        return typeParameters.params
            .map(genericTypeParameter => this.getRangeFromTypeNode(classLoaded, genericTypeParameter, `generic type instantiation on ${classLoaded.localName} in ${classLoaded.fileName}`));
    }
    getQualifiedPath(qualifiedEntity) {
        switch (qualifiedEntity.type) {
            case typescript_estree_1.AST_NODE_TYPES.TSQualifiedName:
                return [...this.getQualifiedPath(qualifiedEntity.left), qualifiedEntity.right.name];
            case typescript_estree_1.AST_NODE_TYPES.Identifier:
                return [qualifiedEntity.name];
        }
    }
    getFieldRange(classLoaded, field, commentData) {
        let range;
        // Check the typescript raw field type
        if (field.typeAnnotation) {
            range = this.getRangeFromTypeNode(classLoaded, field.typeAnnotation.typeAnnotation, this.getErrorIdentifierField(classLoaded, field));
        }
        // Throw if no range was found
        if (!range) {
            this.throwOrWarn(new Error(`Missing field type on ${this.getFieldName(classLoaded, field)} in ${classLoaded.localName} at ${classLoaded.fileName}`));
            return { type: 'wildcard' };
        }
        // If the field has the '?' annotation, explicitly allow undefined as value to make it be considered optional.
        if (field.optional) {
            if (range.type === 'union') {
                // Don't add undefined element if it is already present
                if (!range.elements.some(element => element.type === 'undefined')) {
                    range.elements.push({ type: 'undefined' });
                }
            }
            else {
                range = {
                    type: 'union',
                    elements: [
                        range,
                        { type: 'undefined' },
                    ],
                };
            }
        }
        // Check comment data
        if (commentData.range) {
            range = this.overrideRawRange(range, commentData.range);
        }
        return range;
    }
    /**
     * Apply a range override on the given range
     * @param range The range to override in.
     * @param override The range set set.
     */
    overrideRawRange(range, override) {
        switch (range.type) {
            case 'raw':
            case 'literal':
            case 'hash':
            case 'interface':
            case 'genericTypeReference':
            case 'typeof':
            case 'indexed':
                // Replace these types
                return override;
            case 'undefined':
            case 'wildcard':
            case 'override':
                // Override has no effect here
                return range;
            case 'union':
            case 'intersection':
            case 'tuple':
                // Recursively apply override operation on elements
                return {
                    type: range.type,
                    elements: range.elements.map(element => this.overrideRawRange(element, override)),
                };
            case 'rest':
            case 'array':
            case 'keyof':
                // Recursively apply override operation on value
                return {
                    type: range.type,
                    // TODO: remove the following any cast when TS bug is fixed
                    value: this.overrideRawRange(range.value, override),
                };
        }
    }
    getFieldComment(commentData) {
        return commentData.description;
    }
    /**
     * Load the parameter data from the given index signature.
     * @param classLoaded The loaded class in which the field is defined.
     * @param indexSignature An index signature.
     * @param commentData Comment data about the given field.
     */
    loadIndex(classLoaded, indexSignature, commentData) {
        // Required data
        const parameterData = {
            type: 'index',
            domain: this.getIndexDomain(classLoaded, indexSignature),
            range: this.getIndexRange(classLoaded, indexSignature, commentData),
        };
        // Optional data
        parameterData.defaults = commentData.defaults;
        const comment = this.getFieldComment(commentData);
        if (comment) {
            parameterData.comment = comment;
        }
        return parameterData;
    }
    getIndexDomain(classLoaded, indexSignature) {
        if (indexSignature.parameters.length !== 1) {
            throw new Error(`Expected exactly one key in index signature in ${classLoaded.localName} at ${classLoaded.fileName}`);
        }
        if (indexSignature.parameters[0].type !== 'Identifier') {
            throw new Error(`Only identifier-based index signatures are allowed in ${classLoaded.localName} at ${classLoaded.fileName}`);
        }
        if (!indexSignature.parameters[0].typeAnnotation) {
            throw new Error(`Missing key type annotation in index signature in ${classLoaded.localName} at ${classLoaded.fileName}`);
        }
        const type = this.getRangeFromTypeNode(classLoaded, indexSignature.parameters[0].typeAnnotation.typeAnnotation, this.getErrorIdentifierIndex());
        if (type.type !== 'raw') {
            throw new Error(`Only raw types are allowed in index signature keys in ${classLoaded.localName} at ${classLoaded.fileName}`);
        }
        return type.value;
    }
    getIndexRange(classLoaded, indexSignature, commentData) {
        // Check comment data
        if (commentData.range) {
            return commentData.range;
        }
        // Check the typescript raw field type
        if (indexSignature.typeAnnotation) {
            return this.getRangeFromTypeNode(classLoaded, indexSignature.typeAnnotation.typeAnnotation, this.getErrorIdentifierIndex());
        }
        this.throwOrWarn(new Error(`Missing field type on ${this.getErrorIdentifierIndex()} in ${classLoaded.localName} at ${classLoaded.fileName}`));
        return { type: 'wildcard' };
    }
    /**
     * Iterate over all type reference override handler to see if one of them overrides the given type.
     * @param typeNode A type reference node.
     */
    handleTypeOverride(typeNode) {
        for (const typeReferenceOverride of ParameterLoader.typeReferenceOverrides) {
            const handled = typeReferenceOverride.handle(typeNode);
            if (handled) {
                return handled;
            }
        }
    }
    throwOrWarn(error) {
        if (this.hardErrorUnsupported) {
            throw error;
        }
        else {
            this.logger.error(error.message);
        }
    }
}
exports.ParameterLoader = ParameterLoader;
ParameterLoader.typeReferenceOverrides = [
    new TypeReferenceOverrideAliasRecord_1.TypeReferenceOverrideAliasRecord(),
];
//# sourceMappingURL=ParameterLoader.js.map