"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CommentLoader = void 0;
const commentParse = require("comment-parser");
/**
 * Loads comments from fields in a given class.
 */
class CommentLoader {
    /**
     * Extract comment data from the given constructor inheritance chain.
     * @param constructorChain An array of constructors within the class inheritance chain.
     */
    getCommentDataFromConstructor(constructorChain) {
        // Merge comment data about each field so that the closest classes in the inheritance chain have
        // the highest priority in setting comment data.
        return constructorChain
            .map(constructorHolder => this.getCommentDataFromConstructorSingle(constructorHolder.classLoaded.value, constructorHolder.constructor))
            .reduce((acc, commentData) => {
            for (const [key, value] of Object.entries(commentData)) {
                if (key in acc) {
                    acc[key] = {
                        range: acc[key].range || value.range,
                        defaults: [...acc[key].defaults || [], ...value.defaults || []],
                        ignored: acc[key].ignored || value.ignored,
                        description: acc[key].description || value.description,
                        params: { ...acc[key].params, ...value.params },
                        defaultNested: [...acc[key].defaultNested || [], ...value.defaultNested || []],
                    };
                }
                else {
                    acc[key] = value;
                }
            }
            return acc;
        }, {});
    }
    /**
     * Extract comment data from the given constructor.
     * @param classLoaded The loaded class in which the constructor is defined.
     * @param constructor A constructor.
     */
    getCommentDataFromConstructorSingle(classLoaded, constructor) {
        // Get the constructor comment
        const comment = this.getCommentRaw(classLoaded, constructor);
        if (comment) {
            return CommentLoader.getCommentDataFromConstructorComment(comment, classLoaded);
        }
        return {};
    }
    /**
     * Get comment data from the given constructor comment.
     * @param comment A constructor comment string.
     * @param clazz A class reference, for error reporting.
     */
    static getCommentDataFromConstructorComment(comment, clazz) {
        const data = {};
        // Iterate over all @param's
        const commentData = CommentLoader.getCommentDataFromComment(comment, clazz);
        if (commentData.params) {
            for (const [key, value] of Object.entries(commentData.params)) {
                const subCommentData = CommentLoader.getCommentDataFromComment(`/**${value.replace(/ @/gu, '\n * @')}*/`, clazz);
                // Since we're in the scope of a param (key), prepend the defaultNested paramPath array with the current param.
                if (subCommentData.defaultNested) {
                    for (const defaultNested of subCommentData.defaultNested) {
                        defaultNested.paramPath.unshift(key);
                    }
                }
                data[key] = subCommentData;
            }
        }
        return data;
    }
    /**
     * Extract comment data from the given field.
     * @param classLoaded The loaded class in which the field is defined.
     * @param field A field.
     */
    getCommentDataFromField(classLoaded, field) {
        const comment = this.getCommentRaw(classLoaded, field);
        if (comment) {
            return CommentLoader.getCommentDataFromComment(comment, classLoaded);
        }
        return {};
    }
    /**
     * Extract comment data from the given class.
     * @param classLoaded The loaded class or interface.
     */
    getCommentDataFromClassOrInterface(classLoaded) {
        const comment = this.getCommentRaw(classLoaded, classLoaded.declaration);
        if (comment) {
            return CommentLoader.getCommentDataFromComment(comment, classLoaded);
        }
        return {};
    }
    /**
     * Get comment data from the given comment.
     * @param comment A comment string.
     * @param clazz A class reference, for error reporting.
     */
    static getCommentDataFromComment(comment, clazz) {
        const data = {};
        const commentParsed = commentParse(comment)[0];
        if (commentParsed) {
            // Extract description
            if (commentParsed.description.length > 0) {
                data.description = commentParsed.description.replace(/\n/gu, ' ');
            }
            // Extract tags
            for (const tag of commentParsed.tags) {
                switch (tag.tag.toLowerCase()) {
                    case 'range':
                        if (tag.type.length === 0) {
                            throw new Error(`Missing @range value {something} on a field in class ${clazz.localName} at ${clazz.fileName}`);
                        }
                        data.range = {
                            type: 'override',
                            value: tag.type,
                        };
                        break;
                    case 'default':
                        if (tag.type.length === 0) {
                            throw new Error(`Missing @default value {something} on a field in class ${clazz.localName} at ${clazz.fileName}`);
                        }
                        if (!data.defaults) {
                            data.defaults = [];
                        }
                        data.defaults.push(CommentLoader.getDefaultValue(tag.type, clazz));
                        break;
                    case 'ignored':
                        data.ignored = true;
                        break;
                    case 'param':
                        if (!data.params) {
                            data.params = {};
                        }
                        data.params[tag.name] = tag.description;
                        if (data.params[tag.name].startsWith('- ')) {
                            data.params[tag.name] = data.params[tag.name].slice(2);
                        }
                        break;
                    case 'defaultnested':
                        if (tag.type.length === 0 || tag.name.length === 0) {
                            throw new Error(`Invalid @defaultNested syntax on a field in class ${clazz.localName} at ${clazz.fileName}: expected @defaultNested {<id> a <Type>} path_to_param`);
                        }
                        if (!data.defaultNested) {
                            data.defaultNested = [];
                        }
                        data.defaultNested.push({
                            paramPath: tag.name.split('_'),
                            value: CommentLoader.getDefaultValue(tag.type, clazz),
                        });
                        break;
                }
            }
        }
        return data;
    }
    /**
     * Parse the microsyntax of a default value.
     *
     * Can be one of:
     * * raw value: "abc"
     * * iri value: "<ex:abc>"
     * * type value: "a <ex:Type>"
     * * iri and type value: "<ex:abc> a <ex:Type>"
     *
     * @param value A default value string.
     * @param clazz The class reference this value is loaded in.
     */
    static getDefaultValue(value, clazz) {
        if (!value.startsWith('<') && !value.startsWith('a ')) {
            return {
                type: 'raw',
                value,
            };
        }
        const [idRaw, typeRaw] = value.startsWith('a ') ?
            [undefined, value.slice(2)] :
            value.split(' a ');
        return {
            type: 'iri',
            value: idRaw ? CommentLoader.getIriValue(idRaw) : undefined,
            typeIri: typeRaw ? CommentLoader.getIriValue(typeRaw) : undefined,
            baseComponent: clazz,
        };
    }
    /**
     * Unbox an IRI wrapped in <>
     * @param iriBoxed An iri string within <>
     */
    static getIriValue(iriBoxed) {
        const match = /^<([^>]*)>$/u.exec(iriBoxed);
        return match ? match[1] : undefined;
    }
    /**
     * Get the comment string from the given node.
     * @param classLoaded The loaded class in which the field is defined.
     * @param node A node, such as a field or constructor.
     */
    getCommentRaw(classLoaded, node) {
        const line = node.loc.start.line;
        for (const comment of classLoaded.ast.comments || []) {
            if (comment.loc.end.line === line - 1) {
                return `/*${comment.value}*/`;
            }
        }
    }
}
exports.CommentLoader = CommentLoader;
//# sourceMappingURL=CommentLoader.js.map