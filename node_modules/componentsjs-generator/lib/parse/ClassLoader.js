"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassLoader = void 0;
const Path = require("path");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
/**
 * Loads typescript classes from class references.
 */
class ClassLoader {
    constructor(args) {
        this.resolutionContext = args.resolutionContext;
        this.logger = args.logger;
        this.commentLoader = args.commentLoader;
    }
    /**
     * Find the super class of the given class.
     * Throws an error for super class definitions that could not be interpreted.
     * @param declaration A class declaration.
     * @param fileName The file name of the current class.
     */
    getSuperClassName(declaration, fileName) {
        if (!declaration.superClass) {
            return;
        }
        if (declaration.superClass.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
            // Extensions in the form of `class A extends B`
            return {
                value: declaration.superClass.name,
                genericTypeInstantiations: declaration.superTypeParameters,
            };
        }
        if (declaration.superClass.type === typescript_estree_1.AST_NODE_TYPES.MemberExpression &&
            declaration.superClass.property.type === typescript_estree_1.AST_NODE_TYPES.Identifier &&
            declaration.superClass.object.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
            // Extensions in the form of `class A extends x.B`
            throw new Error(`Namespaced superclasses are currently not supported: ${fileName} on line ${declaration.superClass.loc.start.line} column ${declaration.superClass.loc.start.column}`);
        }
        throw new Error(`Could not interpret type of superclass in ${fileName} on line ${declaration.superClass.loc.start.line} column ${declaration.superClass.loc.start.column}`);
    }
    /**
     * Find the super interfaces of the given interface.
     * Throws an error for interface definitions that could not be interpreted.
     * @param declaration An interface declaration.
     * @param fileName The file name of the current class.
     */
    getSuperInterfaceNames(declaration, fileName) {
        return (declaration.extends || [])
            // eslint-disable-next-line array-callback-return
            .map(extendsExpression => {
            if (extendsExpression.type === typescript_estree_1.AST_NODE_TYPES.TSInterfaceHeritage &&
                extendsExpression.expression.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
                // Extensions in the form of `interface A extends B`
                return {
                    value: extendsExpression.expression.name,
                    genericTypeInstantiations: extendsExpression.typeParameters,
                };
            }
            // Ignore interfaces that we don't understand
            this.logger.debug(`Ignored an interface expression of unknown type ${extendsExpression.expression.type} on ${declaration.id.name}`);
        })
            .filter(iface => Boolean(iface));
    }
    /**
     * Find the interface names of the given class.
     * @param declaration A class declaration.
     * @param fileName The file name of the current class.
     */
    getClassInterfaceNames(declaration, fileName) {
        const interfaceNames = [];
        if (declaration.implements) {
            for (const implement of declaration.implements) {
                if (implement.expression.type !== typescript_estree_1.AST_NODE_TYPES.Identifier) {
                    throw new Error(`Could not interpret the implements type on a class in ${fileName} on line ${implement.expression.loc.start.line} column ${implement.expression.loc.start.column}`);
                }
                interfaceNames.push({
                    value: implement.expression.name,
                    genericTypeInstantiations: implement.typeParameters,
                });
            }
        }
        return interfaceNames;
    }
    /**
     * Load the referenced class, and obtain its full class declaration.
     * Classes can either be defined in this file (exported or not), or imported from another file.
     * @param classReference The reference to a class.
     * @param considerInterfaces If the class reference is allows to refer to an interface, as well as a class.
     * @param considerOthers If the class reference is allows to refer to refer to other things,
     *                       such as a type alias or enum.
     */
    async loadClassDeclaration(classReference, considerInterfaces, considerOthers) {
        let targetString = 'class';
        if (considerInterfaces) {
            targetString += ' or interface';
        }
        if (considerOthers) {
            targetString += ' or other type';
        }
        // Load the class as an AST
        let ast;
        try {
            ast = await this.resolutionContext.parseTypescriptFile(classReference.fileName);
        }
        catch (error) {
            const name = `${classReference.qualifiedPath && classReference.qualifiedPath.length > 0 ? `${classReference.qualifiedPath.join('.')}.` : ''}${classReference.localName}`;
            throw new Error(`Could not load ${targetString} ${name} from ${classReference.fileName}:\n${error.message}`);
        }
        return this.loadClassDeclarationFromAst(ast, targetString, classReference, considerInterfaces, considerOthers);
    }
    /**
     * Load the referenced class, and obtain its full class declaration.
     * Classes can either be defined in this file (exported or not), or imported from another file.
     * @param ast An abstract syntax tree.
     * @param targetString A string for error reporting on the considered scope.
     * @param classReference The reference to a class.
     * @param considerInterfaces If the class reference is allows to refer to an interface, as well as a class.
     * @param considerOthers If the class reference is allows to refer to refer to other things,
     *                       such as a type alias or enum.
     */
    async loadClassDeclarationFromAst(ast, targetString, classReference, considerInterfaces, considerOthers) {
        const { exportedClasses, exportedInterfaces, exportedTypes, exportedEnums, exportedImportedAllNamed, declaredClasses, declaredInterfaces, declaredTypes, declaredEnums, declaredNamespaces, importedElements, importedElementsAllNamed, exportedImportedAll, exportedImportedElements, exportAssignment, } = this.getClassElements(classReference.packageName, classReference.fileName, ast);
        let componentName;
        let qualifiedPathInner;
        if (classReference.qualifiedPath && classReference.qualifiedPath.length > 0) {
            // In all following code, look for the qualified path head
            componentName = classReference.qualifiedPath[0];
            // For recursive calls to getClassElements, we'll have to slice off the head
            qualifiedPathInner = classReference.qualifiedPath.slice(1);
        }
        else {
            // Otherwise if we don't have a qualified path, look for the class name
            componentName = classReference.localName;
            // If the class has been exported in this file, return directly
            if (componentName in exportedClasses) {
                const declaration = exportedClasses[componentName];
                return this.enhanceLoadedWithComment({
                    type: 'class',
                    ...classReference,
                    declaration,
                    ast,
                    abstract: declaration.abstract,
                    generics: this.collectGenericTypes(declaration),
                });
            }
            // If the class has been declared in this file, return directly
            if (componentName in declaredClasses) {
                const declaration = declaredClasses[componentName];
                return this.enhanceLoadedWithComment({
                    type: 'class',
                    ...classReference,
                    declaration,
                    ast,
                    abstract: declaration.abstract,
                    generics: this.collectGenericTypes(declaration),
                });
            }
            // Only consider interfaces if explicitly enabled
            if (considerInterfaces) {
                // If the interface has been exported in this file, return directly
                if (componentName in exportedInterfaces) {
                    const declaration = exportedInterfaces[componentName];
                    return this.enhanceLoadedWithComment({
                        type: 'interface',
                        ...classReference,
                        declaration,
                        ast,
                        generics: this.collectGenericTypes(declaration),
                    });
                }
                // If the interface has been declared in this file, return directly
                if (componentName in declaredInterfaces) {
                    const declaration = declaredInterfaces[componentName];
                    return this.enhanceLoadedWithComment({
                        type: 'interface',
                        ...classReference,
                        declaration,
                        ast,
                        generics: this.collectGenericTypes(declaration),
                    });
                }
            }
            // Only consider other types if explicitly enabled
            if (considerOthers) {
                // Check types
                if (componentName in exportedTypes) {
                    const declaration = exportedTypes[componentName];
                    return this.enhanceLoadedWithComment({
                        type: 'type',
                        ...classReference,
                        declaration,
                        ast,
                        generics: this.collectGenericTypes(declaration),
                    });
                }
                if (componentName in declaredTypes) {
                    const declaration = declaredTypes[componentName];
                    return this.enhanceLoadedWithComment({
                        type: 'type',
                        ...classReference,
                        declaration,
                        ast,
                        generics: this.collectGenericTypes(declaration),
                    });
                }
                // Check enums
                if (componentName in exportedEnums) {
                    const declaration = exportedEnums[componentName];
                    return this.enhanceLoadedWithComment({
                        type: 'enum',
                        ...classReference,
                        declaration,
                        ast,
                    });
                }
                if (componentName in declaredEnums) {
                    const declaration = declaredEnums[componentName];
                    return this.enhanceLoadedWithComment({
                        type: 'enum',
                        ...classReference,
                        declaration,
                        ast,
                    });
                }
            }
        }
        // If we haven't found anything so far, we will follow import/export links.
        // If the class is available via an import, follow that import link
        if (componentName in importedElements) {
            const entry = importedElements[componentName];
            let localNameInner;
            if (qualifiedPathInner) {
                localNameInner = classReference.localName;
                qualifiedPathInner = [entry.localName, ...qualifiedPathInner];
            }
            else {
                localNameInner = entry.localName;
            }
            return this.loadClassDeclaration({
                ...entry,
                localName: localNameInner,
                qualifiedPath: qualifiedPathInner,
                fileNameReferenced: classReference.fileNameReferenced,
            }, considerInterfaces, considerOthers);
        }
        // If the class is available via an exported import, follow that import link
        if (componentName in exportedImportedElements) {
            const entry = exportedImportedElements[componentName];
            let localNameInner;
            if (qualifiedPathInner) {
                localNameInner = classReference.localName;
                qualifiedPathInner = [entry.localName, ...qualifiedPathInner];
            }
            else {
                localNameInner = entry.localName;
            }
            return this.loadClassDeclaration({
                ...entry,
                localName: localNameInner,
                qualifiedPath: qualifiedPathInner,
                fileNameReferenced: classReference.fileNameReferenced,
            }, considerInterfaces, considerOthers);
        }
        // Check for named exported elements
        if (componentName in exportedImportedAllNamed) {
            return await this.loadClassDeclaration({
                localName: classReference.localName,
                qualifiedPath: qualifiedPathInner,
                ...exportedImportedAllNamed[componentName],
                fileNameReferenced: classReference.fileNameReferenced,
            }, considerInterfaces, considerOthers);
        }
        // Follow named import links
        if (componentName in importedElementsAllNamed) {
            return await this.loadClassDeclaration({
                localName: classReference.localName,
                qualifiedPath: qualifiedPathInner,
                ...importedElementsAllNamed[componentName],
                fileNameReferenced: classReference.fileNameReferenced,
            }, considerInterfaces, considerOthers);
        }
        // Check enum values
        if (classReference.qualifiedPath && classReference.qualifiedPath.length === 1) {
            const enumName = classReference.qualifiedPath[0];
            const enumKey = classReference.localName;
            const enumDeclaration = exportedEnums[enumName] || declaredEnums[enumName];
            if (enumDeclaration) {
                for (const enumMember of enumDeclaration.members) {
                    if (enumMember.id.type === typescript_estree_1.AST_NODE_TYPES.Identifier && enumMember.id.name === enumKey &&
                        enumMember.initializer && enumMember.initializer.type === typescript_estree_1.AST_NODE_TYPES.Literal) {
                        // Expose the enum entry as type alias
                        const typeNode = {
                            type: typescript_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration,
                            id: {
                                type: typescript_estree_1.AST_NODE_TYPES.Identifier,
                                name: enumKey,
                                loc: undefined,
                                range: undefined,
                            },
                            typeAnnotation: {
                                type: typescript_estree_1.AST_NODE_TYPES.TSLiteralType,
                                literal: enumMember.initializer,
                                loc: undefined,
                                range: undefined,
                            },
                            loc: undefined,
                            range: undefined,
                        };
                        return {
                            type: 'type',
                            ...classReference,
                            declaration: typeNode,
                            ast,
                        };
                    }
                }
            }
        }
        // If we still haven't found the class, iterate over all export all's
        for (const subFile of exportedImportedAll) {
            try {
                return await this.loadClassDeclaration({
                    localName: classReference.localName,
                    qualifiedPath: qualifiedPathInner,
                    ...subFile,
                    fileNameReferenced: classReference.fileNameReferenced,
                }, considerInterfaces, considerOthers);
            }
            catch {
                // Ignore class not found errors
            }
        }
        // Check if the export assignment refers to a namespace
        if (exportAssignment && typeof exportAssignment === 'string' && exportAssignment in declaredNamespaces) {
            const namespace = declaredNamespaces[exportAssignment];
            return this.loadClassDeclarationFromAst(namespace.body, targetString, classReference, considerInterfaces, considerOthers);
        }
        const name = `${classReference.qualifiedPath && classReference.qualifiedPath.length > 0 ? `${classReference.qualifiedPath.join('.')}.` : ''}${classReference.localName}`;
        throw new Error(`Could not load ${targetString} ${name} from ${classReference.fileName}`);
    }
    /**
     * Create a hash of generic types in the given class declaration.
     * @param classDeclaration A class or interface declaration.
     */
    collectGenericTypes(classDeclaration) {
        const genericTypes = {};
        if (classDeclaration.typeParameters) {
            for (const param of classDeclaration.typeParameters.params) {
                genericTypes[param.name.name] = { type: param.constraint };
            }
        }
        return genericTypes;
    }
    /**
     * Annotate the given loaded class or interface with a comment if it is present on the declaration.
     * @param classLoaded A loaded class or interface.
     */
    enhanceLoadedWithComment(classLoaded) {
        const commentData = this.commentLoader.getCommentDataFromClassOrInterface(classLoaded);
        if (commentData.description) {
            classLoaded.comment = commentData.description;
        }
        return classLoaded;
    }
    /**
     * Load a class, and get all class elements from it.
     * @param packageName Package name we are importing from.
     * @param filePath A file path.
     * @returns {Promise<ClassElements & { resolvedPath: string }>} Promise of the class elements along with
     * the resolved file path that was used to load these class elements.
     */
    async loadClassElements(packageName, filePath) {
        const resolvedPath = await this.resolutionContext.resolveTypesPath(filePath);
        const ast = await this.resolutionContext.parseTypescriptFile(resolvedPath);
        const classElements = this.getClassElements(packageName, resolvedPath, ast);
        return { ...classElements, resolvedPath };
    }
    /**
     * Convert the given import path to an absolute file path, coupled with the module it is part of.
     * Result is `undefined` if there was an error resolving the package.
     * @param currentPackageName Package name we are importing from.
     * @param currentFilePath Absolute path to a file in which the import path occurs.
     * @param importPath Possibly relative path that is being imported.
     */
    importTargetToAbsolutePath(currentPackageName, currentFilePath, importPath) {
        // Handle import paths within the current package
        if (importPath.startsWith('.')) {
            return {
                packageName: currentPackageName,
                fileName: Path.join(Path.dirname(currentFilePath), importPath),
                fileNameReferenced: currentFilePath,
            };
        }
        // Handle import paths to other packages
        let packageName;
        let packagePath;
        if (importPath.startsWith('@')) {
            const slashIndexFirst = importPath.indexOf('/');
            if (slashIndexFirst < 0) {
                throw new Error(`Invalid scoped package name for import path '${importPath}' in '${currentFilePath}'`);
            }
            const slashIndexSecond = importPath.indexOf('/', slashIndexFirst + 1);
            if (slashIndexSecond < 0) {
                // Import form: "@scope/package"
                packageName = importPath;
            }
            else {
                // Import form: "@scope/package/path"
                packageName = importPath.slice(0, Math.max(0, slashIndexSecond));
                packagePath = importPath.slice(slashIndexSecond + 1);
            }
        }
        else {
            const slashIndex = importPath.indexOf('/');
            if (slashIndex < 0) {
                // Import form: "package"
                packageName = importPath;
            }
            else {
                // Import form: "package/path"
                packageName = importPath.slice(0, Math.max(0, slashIndex));
                packagePath = importPath.slice(slashIndex + 1);
            }
        }
        // Resolve paths
        let packageRoot;
        try {
            packageRoot = this.resolutionContext.resolvePackageIndex(packageName, currentFilePath);
        }
        catch (error) {
            this.logger.warn(`Ignoring invalid package "${packageName}": ${error.message}`);
            return;
        }
        const remoteFilePath = packagePath ?
            Path.join(Path.dirname(packageRoot), packagePath) :
            packageRoot.slice(0, packageRoot.indexOf('.', packageRoot.lastIndexOf('/')));
        return {
            packageName,
            fileName: remoteFilePath,
            fileNameReferenced: currentFilePath,
        };
    }
    /**
     * Get all class elements in a file.
     * @param packageName Package name we are importing from.
     * @param fileName A file path.
     * @param ast The parsed file.
     */
    getClassElements(packageName, fileName, ast) {
        const exportedClasses = {};
        const exportedInterfaces = {};
        const exportedTypes = {};
        const exportedEnums = {};
        const exportedNamespaces = {};
        const exportedImportedElements = {};
        const exportedImportedAll = [];
        const exportedImportedAllNamed = {};
        const exportedUnknowns = {};
        const declaredClasses = {};
        const declaredInterfaces = {};
        const declaredTypes = {};
        const declaredEnums = {};
        const declaredNamespaces = {};
        const importedElements = {};
        const importedElementsAllNamed = {};
        let exportAssignment;
        for (const statement of ast.body) {
            if (statement.type === typescript_estree_1.AST_NODE_TYPES.ExportNamedDeclaration) {
                if (statement.declaration &&
                    statement.declaration.type === typescript_estree_1.AST_NODE_TYPES.ClassDeclaration) {
                    // Form: `export class A{}`
                    if (!statement.declaration.id) {
                        throw new Error(`Export parsing failure: missing exported class name in ${fileName} on line ${statement.declaration.loc.start.line} column ${statement.declaration.loc.start.column}`);
                    }
                    exportedClasses[statement.declaration.id.name] = statement.declaration;
                }
                else if (statement.declaration &&
                    statement.declaration.type === typescript_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration) {
                    // Form: `export interface A{}`
                    exportedInterfaces[statement.declaration.id.name] = statement.declaration;
                }
                else if (statement.declaration && statement.declaration.type === typescript_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration) {
                    // Form: `export type A = ...`
                    exportedTypes[statement.declaration.id.name] = statement.declaration;
                }
                else if (statement.declaration && statement.declaration.type === typescript_estree_1.AST_NODE_TYPES.TSEnumDeclaration) {
                    // Form: `export enum A {...}`
                    exportedEnums[statement.declaration.id.name] = statement.declaration;
                }
                else if (statement.declaration && statement.declaration.type === typescript_estree_1.AST_NODE_TYPES.TSModuleDeclaration &&
                    'name' in statement.declaration.id) {
                    // Form: `export namespace A { ... }`
                    exportedNamespaces[statement.declaration.id.name] = statement.declaration;
                }
                else if (statement.source &&
                    statement.source.type === typescript_estree_1.AST_NODE_TYPES.Literal &&
                    typeof statement.source.value === 'string') {
                    // Form: `export { A as B } from "b"`
                    for (const specifier of statement.specifiers) {
                        const entry = this.importTargetToAbsolutePath(packageName, fileName, statement.source.value);
                        if (entry) {
                            exportedImportedElements[specifier.exported.name] = {
                                localName: specifier.local.name,
                                qualifiedPath: undefined,
                                ...entry,
                            };
                        }
                    }
                }
                else {
                    // Form: `export { A as B }`
                    for (const specifier of statement.specifiers) {
                        exportedUnknowns[specifier.exported.name] = specifier.local.name;
                    }
                }
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.ExportAllDeclaration) {
                // Form: `export * from "b"` or `export * as B from "b"`
                if (statement.source &&
                    statement.source.type === typescript_estree_1.AST_NODE_TYPES.Literal &&
                    typeof statement.source.value === 'string') {
                    const entry = this.importTargetToAbsolutePath(packageName, fileName, statement.source.value);
                    if (entry) {
                        if (statement.exported) {
                            exportedImportedAllNamed[statement.exported.name] = entry;
                        }
                        else {
                            exportedImportedAll.push(entry);
                        }
                    }
                }
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.TSExportAssignment) {
                // Form: `export = ...`
                if (statement.expression.type === typescript_estree_1.AST_NODE_TYPES.Identifier) {
                    exportAssignment = statement.expression.name;
                }
                else if (statement.expression.type === typescript_estree_1.AST_NODE_TYPES.ClassExpression) {
                    exportAssignment = {
                        ...statement.expression,
                        type: typescript_estree_1.AST_NODE_TYPES.ClassDeclaration,
                    };
                }
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.ClassDeclaration && statement.id) {
                // Form: `declare class A {}`
                declaredClasses[statement.id.name] = statement;
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.TSInterfaceDeclaration && statement.id) {
                // Form: `declare interface A {}`
                declaredInterfaces[statement.id.name] = statement;
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.TSTypeAliasDeclaration && statement.id) {
                // Form: `declare type A = ...`
                declaredTypes[statement.id.name] = statement;
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.TSEnumDeclaration && statement.id) {
                // Form: `declare enum A {...}`
                declaredEnums[statement.id.name] = statement;
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.TSModuleDeclaration && statement.id && 'name' in statement.id) {
                // Form `declare namespace A { ... }
                declaredNamespaces[statement.id.name] = statement;
            }
            else if (statement.type === typescript_estree_1.AST_NODE_TYPES.ImportDeclaration &&
                statement.source.type === typescript_estree_1.AST_NODE_TYPES.Literal &&
                typeof statement.source.value === 'string') {
                const entry = this.importTargetToAbsolutePath(packageName, fileName, statement.source.value);
                if (entry) {
                    for (const specifier of statement.specifiers) {
                        if (specifier.type === typescript_estree_1.AST_NODE_TYPES.ImportSpecifier) {
                            // Form: `import {A} from './lib/A'`
                            importedElements[specifier.local.name] = {
                                localName: specifier.imported.name,
                                qualifiedPath: undefined,
                                ...entry,
                            };
                        }
                        else if (specifier.type === typescript_estree_1.AST_NODE_TYPES.ImportNamespaceSpecifier) {
                            // Form: `import * as A from './lib/A'`
                            importedElementsAllNamed[specifier.local.name] = entry;
                        }
                    }
                }
            }
        }
        return {
            exportedClasses,
            exportedInterfaces,
            exportedTypes,
            exportedEnums,
            exportedNamespaces,
            exportedImportedElements,
            exportedImportedAll,
            exportedImportedAllNamed,
            exportedUnknowns,
            declaredClasses,
            declaredInterfaces,
            declaredTypes,
            declaredEnums,
            declaredNamespaces,
            importedElements,
            importedElementsAllNamed,
            exportAssignment,
        };
    }
}
exports.ClassLoader = ClassLoader;
//# sourceMappingURL=ClassLoader.js.map