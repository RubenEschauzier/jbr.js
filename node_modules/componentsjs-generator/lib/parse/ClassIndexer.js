"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClassIndexer = void 0;
class ClassIndexer {
    constructor(args) {
        this.classLoader = args.classLoader;
        this.classFinder = args.classFinder;
        this.ignoreClasses = args.ignoreClasses;
        this.logger = args.logger;
    }
    /**
     * Load all class references in the given class index.
     * @param classReferences An index of class references.
     */
    async createIndex(classReferences) {
        const classIndex = {};
        for (const [className, classReference] of Object.entries(classReferences)) {
            if (!(className in this.ignoreClasses)) {
                classIndex[className] = await this.loadClassChain(classReference);
            }
        }
        return classIndex;
    }
    /**
     * Load the referenced class, and obtain all required information,
     * such as its declaration and loaded super class referenced.
     * @param classReference The reference to a class or interface.
     */
    async loadClassChain(classReference) {
        // Load the class declaration
        const classReferenceLoaded = await this.classLoader
            .loadClassDeclaration(classReference, true, false);
        if (classReferenceLoaded.type === 'class') {
            // If the class has a super class, load it recursively
            const superClassName = this.classLoader.getSuperClassName(classReferenceLoaded.declaration, classReferenceLoaded.fileName);
            if (superClassName && !(superClassName.value in this.ignoreClasses)) {
                let superClassLoaded;
                try {
                    superClassLoaded = await this.loadClassChain({
                        packageName: classReferenceLoaded.packageName,
                        localName: superClassName.value,
                        qualifiedPath: classReferenceLoaded.qualifiedPath,
                        fileName: classReferenceLoaded.fileName,
                        fileNameReferenced: classReferenceLoaded.fileNameReferenced,
                    });
                }
                catch (error) {
                    throw new Error(`Failed to load super class ${superClassName.value} of ${classReference.localName} in ${classReference.fileName}:\n${error.message}`);
                }
                if (superClassLoaded.type !== 'class') {
                    throw new Error(`Detected non-class ${superClassName.value} extending from a class ${classReference.localName} in ${classReference.fileName}`);
                }
                classReferenceLoaded.superClass = {
                    value: superClassLoaded,
                    genericTypeInstantiations: superClassName.genericTypeInstantiations,
                };
            }
            // If the class implements interfaces, load them
            const interfaceNames = this.classLoader.getClassInterfaceNames(classReferenceLoaded.declaration, classReferenceLoaded.fileName);
            classReferenceLoaded.implementsInterfaces = (await Promise
                .all(interfaceNames
                .filter(interfaceName => !(interfaceName.value in this.ignoreClasses))
                .map(async (interfaceName) => {
                let interfaceOrClassLoaded;
                try {
                    interfaceOrClassLoaded = await this.classLoader.loadClassDeclaration({
                        packageName: classReferenceLoaded.packageName,
                        localName: interfaceName.value,
                        qualifiedPath: classReferenceLoaded.qualifiedPath,
                        fileName: classReferenceLoaded.fileName,
                        fileNameReferenced: classReferenceLoaded.fileNameReferenced,
                    }, true, false);
                }
                catch (error) {
                    // Ignore interfaces that we don't understand
                    this.logger.debug(`Ignored interface ${interfaceName.value} implemented by ${classReference.localName} in ${classReference.fileName}:\n${error.message}`);
                    return;
                }
                return {
                    value: interfaceOrClassLoaded,
                    genericTypeInstantiations: interfaceName.genericTypeInstantiations,
                };
            })))
                .filter(iface => Boolean(iface));
        }
        else {
            const superInterfaceNames = this.classLoader
                .getSuperInterfaceNames(classReferenceLoaded.declaration, classReferenceLoaded.fileName);
            classReferenceLoaded.superInterfaces = (await Promise
                .all(superInterfaceNames
                .filter(interfaceName => !(interfaceName.value in this.ignoreClasses))
                .map(async (interfaceName) => {
                let superInterface;
                try {
                    superInterface = await this.loadClassChain({
                        packageName: classReferenceLoaded.packageName,
                        localName: interfaceName.value,
                        qualifiedPath: classReferenceLoaded.qualifiedPath,
                        fileName: classReferenceLoaded.fileName,
                        fileNameReferenced: classReferenceLoaded.fileNameReferenced,
                    });
                }
                catch (error) {
                    // Ignore interfaces that we don't understand
                    this.logger.debug(`Ignored interface ${interfaceName.value} extended by ${classReference.localName} in ${classReference.fileName}:\n${error.message}`);
                    return;
                }
                if (superInterface.type !== 'interface') {
                    throw new Error(`Detected non-interface ${classReferenceLoaded.localName} extending from a class ${interfaceName.value} in ${classReference.fileName}`);
                }
                return {
                    value: superInterface,
                    genericTypeInstantiations: interfaceName.genericTypeInstantiations,
                };
            })))
                .filter(iface => Boolean(iface));
        }
        return classReferenceLoaded;
    }
}
exports.ClassIndexer = ClassIndexer;
//# sourceMappingURL=ClassIndexer.js.map