"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageMetadataLoader = void 0;
const Path = require("path");
const semverMajor = require("semver/functions/major");
/**
 * Load metadata from a package.
 */
class PackageMetadataLoader {
    constructor(args) {
        this.resolutionContext = args.resolutionContext;
        this.prefixes = args.prefixes;
    }
    /**
     * Load the metadata from the given package.
     * @param packageRootDirectory The path to a package that should contain a package.json.
     */
    async load(packageRootDirectory) {
        // Read package.json
        const packageJsonPath = Path.join(packageRootDirectory, 'package.json');
        const packageJsonRaw = await this.resolutionContext.getFileContent(packageJsonPath);
        let packageJson;
        try {
            packageJson = JSON.parse(packageJsonRaw);
        }
        catch (error) {
            throw new Error(`Invalid package: Syntax error in ${packageJsonPath}: ${error.message}`);
        }
        // Preprocess to expand `"lsd:module": true`
        if (packageJson['lsd:module'] === true) {
            packageJson['lsd:module'] = `https://linkedsoftwaredependencies.org/bundles/npm/${packageJson.name}`;
            const basePath = packageJson['lsd:basePath'] || '';
            packageJson['lsd:components'] = `${basePath}components/components.jsonld`;
            const baseIri = `${packageJson['lsd:module']}/^${semverMajor(packageJson.version)}.0.0/`;
            packageJson['lsd:contexts'] = {
                [`${baseIri}components/context.jsonld`]: `${basePath}components/context.jsonld`,
            };
            packageJson['lsd:importPaths'] = {
                [`${baseIri}components/`]: `${basePath}components/`,
                [`${baseIri}config/`]: `${basePath}config/`,
            };
        }
        // Extract required fields from package.json
        const name = packageJson.name;
        const version = packageJson.version;
        if (!('lsd:module' in packageJson)) {
            throw new Error(`Invalid package: Missing 'lsd:module' IRI in ${packageJsonPath}`);
        }
        const moduleIri = packageJson['lsd:module'];
        if (!('lsd:components' in packageJson)) {
            throw new Error(`Invalid package: Missing 'lsd:components' in ${packageJsonPath}`);
        }
        const componentsPath = Path.join(packageRootDirectory, packageJson['lsd:components']);
        if (!('lsd:contexts' in packageJson)) {
            throw new Error(`Invalid package: Missing 'lsd:contexts' in ${packageJsonPath}`);
        }
        const contexts = packageJson['lsd:contexts'];
        if (!('lsd:importPaths' in packageJson)) {
            throw new Error(`Invalid package: Missing 'lsd:importPaths' in ${packageJsonPath}`);
        }
        const importPaths = packageJson['lsd:importPaths'];
        if (!('types' in packageJson) && !('typings' in packageJson)) {
            throw new Error(`Invalid package: Missing 'types' or 'typings' in ${packageJsonPath}`);
        }
        let typesPath = Path.join(packageRootDirectory, packageJson.types || packageJson.typings);
        if (typesPath.endsWith('.d.ts')) {
            typesPath = typesPath.slice(0, -5);
        }
        // Determine prefixes
        const prefix = !this.prefixes || typeof this.prefixes === 'string' ? this.prefixes : this.prefixes[name];
        // Construct metadata hash
        return {
            name,
            version,
            moduleIri,
            componentsPath,
            contexts,
            importPaths,
            typesPath,
            prefix,
        };
    }
}
exports.PackageMetadataLoader = PackageMetadataLoader;
//# sourceMappingURL=PackageMetadataLoader.js.map