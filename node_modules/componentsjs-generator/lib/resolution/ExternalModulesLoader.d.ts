/// <reference types="node" />
import type { IModuleState } from 'componentsjs';
import type { JsonLdContextNormalized } from 'jsonld-context-parser';
import type { Logger } from 'winston';
import type { ClassIndex, ClassReferenceLoaded } from '../parse/ClassIndex';
import type { ConstructorData } from '../parse/ConstructorLoader';
import type { PackageMetadata } from '../parse/PackageMetadataLoader';
import type { ParameterRangeResolved } from '../parse/ParameterLoader';
import type { PathDestinationDefinition } from '../serialize/ComponentConstructor';
import type { ResolutionContext } from './ResolutionContext';
/**
 * Loads components from Node modules.
 */
export declare class ExternalModulesLoader {
    private readonly pathDestination;
    private readonly packageMetadata;
    private readonly packagesBeingGenerated;
    private readonly resolutionContext;
    private readonly debugState;
    private readonly logger;
    constructor(args: ExternalModulesLoaderArgs);
    /**
     * Determine packages referred to by components.
     * @param classIndex The available classes.
     * @param constructors The available constructors.
     */
    findExternalPackages(classIndex: ClassIndex<ClassReferenceLoaded>, constructors: ClassIndex<ConstructorData<ParameterRangeResolved>>): string[];
    indexClassInExternalPackage(classReference: ClassReferenceLoaded, externalPackages: Record<string, boolean>): void;
    indexParameterRangeInExternalPackage(parameterRange: ParameterRangeResolved, externalPackages: Record<string, boolean>): void;
    /**
     * Build the module state.
     * Adapted from {@link ModuleStateBuilder#buildModuleState}.
     *
     * Instead of loading the modules for all available packages,
     * only the packages with their name included in the packageNames array are included.
     * This leads to better performance, as we usually need only a small subset of all packages.
     *
     * @param req The `require` instance.
     * @param packageNames Names of the packages to load.
     */
    buildModuleStateSelective(req: NodeJS.Require, packageNames: string[]): Promise<IModuleState>;
    /**
     * Get all currently available node module paths.
     * Adapted from {@link ModuleStateBuilder#buildNodeModulePaths}.
     * Invalid packages will be ignored and filtered out.
     * @param req The `require` instance.
     * @param nodeModuleImportPaths The import paths to resolve from.
     * @param packageNames The package names to resolve the path for.
     */
    buildNodeModulePathsSelective(req: NodeJS.Require, nodeModuleImportPaths: string[], packageNames: string[]): string[];
    /**
     * Loads all components from the given Node package names.
     * @param req The `require` instance.
     * @param externalPackages
     */
    loadExternalComponents(req: NodeJS.Require, externalPackages: string[]): Promise<ExternalComponents>;
    /**
     * Create a 'componentsjs-debug-state.json' file with the given module state.
     * @param moduleState The module state to dump.
     * @param externalPackages The external packages to include in the dump.
     */
    dumpModuleState(moduleState: IModuleState, externalPackages: string[]): Promise<void>;
}
/**
 * Data object for external components.
 */
export interface ExternalComponents {
    /**
     * Module state.
     */
    moduleState: IModuleState;
    /**
     * Maps package name to exported class name to component IRI.
     */
    components: Record<string, {
        contextIris: string[];
        componentNamesToIris: Record<string, string>;
    }>;
    /**
     * Maps package name to package metadata.
     */
    packagesBeingGenerated: Record<string, PackageMetadataScope>;
}
export interface ExternalModulesLoaderArgs {
    pathDestination: PathDestinationDefinition;
    packageMetadata: PackageMetadata;
    /**
     * Maps package name to package metadata.
     */
    packagesBeingGenerated: Record<string, PackageMetadataScope>;
    resolutionContext: ResolutionContext;
    debugState: boolean;
    logger: Logger;
}
export interface PackageMetadataScope {
    packageMetadata: PackageMetadata;
    pathDestination: PathDestinationDefinition;
    minimalContext: JsonLdContextNormalized;
}
