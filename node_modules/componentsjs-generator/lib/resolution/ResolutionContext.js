"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResolutionContext = void 0;
const fs = require("fs");
const Path = require("path");
const typescript_estree_1 = require("@typescript-eslint/typescript-estree");
const LRUCache = require("lru-cache");
/**
 * Context for loading files.
 */
class ResolutionContext {
    constructor() {
        this.parsedCache = new LRUCache(2048);
    }
    /**
     * Reads the content of a file
     * @param filePath The file path
     * @return The content of the file
     */
    getFileContent(filePath) {
        return new Promise((resolve, reject) => {
            fs.readFile(filePath, 'utf8', (error, data) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    /**
     * Resolve the correct type declarations path for a specific path used
     * in the exports.
     *
     * @param {string} filePath File path without .d.ts
     * @returns {Promise<string>} Promise of the file path without .d.ts that is
     *  either equal to the parameter or the index of the directory.
     */
    resolveTypesPath(filePath) {
        return new Promise(resolve => {
            fs.access(`${filePath}.d.ts`, error => {
                if (error) {
                    // No file found, treat as directory with an index
                    filePath = Path.normalize(`${filePath}/index`);
                }
                resolve(filePath);
            });
        });
    }
    /**
     * Write the content of a file.
     * If any of the underlying directories do not exist, they will be created.
     *
     * @param filePath The file path.
     * @param content The content of the file.
     */
    async writeFileContent(filePath, content) {
        await new Promise((resolve, reject) => {
            fs.mkdir(Path.dirname(filePath), { recursive: true }, error => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
        await new Promise((resolve, reject) => {
            fs.writeFile(filePath, content, 'utf8', error => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve();
                }
            });
        });
    }
    /**
     * Gets the content of a TypeScript file based on its filepath without extension
     * @param filePath A typescript file path, without extension.
     * @return The content of the file
     */
    async getTypeScriptFileContent(filePath) {
        return this.getFileContent(`${filePath}.d.ts`);
    }
    /**
     * Parse the given typescript contents into an abstract syntax tree.
     * @param contents Typescript file contents.
     * @return An abstract syntax tree.
     */
    parseTypescriptContents(contents) {
        return (0, typescript_estree_1.parse)(contents, { loc: true, comment: true });
    }
    /**
     * Parse a given typescript file into an abstract syntax tree.
     * This method has a built-in cache, so repeated calls for the same file are safe.
     * @param filePath A typescript file path, without extension.
     * @return - An abstract syntax tree.
     */
    async parseTypescriptFile(filePath) {
        // First check cache
        const cached = this.parsedCache.get(filePath);
        if (cached) {
            return cached;
        }
        const indexContent = await this.getTypeScriptFileContent(filePath);
        try {
            const parsed = this.parseTypescriptContents(indexContent);
            this.parsedCache.set(filePath, parsed);
            return parsed;
        }
        catch (error) {
            throw new Error(`Could not parse file ${filePath}, invalid syntax at line ${error.lineNumber}, column ${error.column}. Message: ${error.message}`);
        }
    }
    /**
     * Determine the path to the index file of the given package.
     * @param packageName A package name.
     * @param currentFilePath The file from which resolution should start.
     *                        The requested package has to be a dependency of this file's package.
     */
    resolvePackageIndex(packageName, currentFilePath) {
        try {
            // First check if we have an @types package
            return this.resolvePackageIndexInner(require, `@types/${packageName}`, currentFilePath);
        }
        catch {
            try {
                // Fallback to the actual package
                return this.resolvePackageIndexInner(require, packageName, currentFilePath);
            }
            catch {
                // As final fallback, check if the package is a valid Node.js built-in like 'stream'.
                require.resolve(packageName, { paths: [currentFilePath] });
                // If so, require the Node.js types, and resolve the file for the built-in package
                const rootFile = this.resolvePackageIndexInner(require, `@types/node`, currentFilePath);
                return rootFile.replace(/index\.d\.ts$/u, `${packageName}.d.ts`);
            }
        }
    }
    resolvePackageIndexInner(req, packageName, currentFilePath) {
        const packageJsonPath = req.resolve(`${packageName}/package.json`, { paths: [currentFilePath] });
        const packageJson = req(packageJsonPath);
        let typesPath = packageJson.types || packageJson.typings || packageJson.main.replace(/\.js$/u, '.d.ts');
        if (!typesPath.endsWith('.d.ts')) {
            typesPath += '.d.ts';
        }
        return Path.join(Path.dirname(packageJsonPath), typesPath);
    }
}
exports.ResolutionContext = ResolutionContext;
//# sourceMappingURL=ResolutionContext.js.map