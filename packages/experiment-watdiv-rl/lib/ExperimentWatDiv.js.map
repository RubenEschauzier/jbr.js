{"version":3,"file":"ExperimentWatDiv.js","sourceRoot":"","sources":["ExperimentWatDiv.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Path from 'path';\nimport * as fs from 'fs-extra';\nimport { secureProcessHandler } from 'jbr';\nimport type { Experiment, Hook, ICleanTargets, ITaskContext } from 'jbr';\nimport { readQueries, SparqlBenchmarkRunner, writeBenchmarkResults } from 'sparql-benchmark-runner';\n\n/**\n * An experiment instance for the LDBC SNB Decentralized benchmark.\n */\nexport class ExperimentWatDiv implements Experiment {\n  public static readonly DOCKER_IMAGE_WATDIV = `comunica/watdiv@sha256:2fac67737d6dddd75ea023b90bba2a1c7432a00e233791a802e374e3d2a8ec3b`;\n  public static readonly DOCKER_IMAGE_HDT = `rdfhdt/hdt-cpp:v1.3.3`;\n  public readonly datasetScale: number;\n  public readonly queryCount: number;\n  public readonly queryRecurrence: number;\n  public readonly generateHdt: boolean;\n  public readonly hookSparqlEndpoint: Hook;\n  public readonly endpointUrl: string;\n  public readonly queryRunnerReplication: number;\n  public readonly queryRunnerWarmupRounds: number;\n  public readonly queryRunnerRecordTimestamps: boolean;\n  public readonly queryRunnerRecordHttpRequests: boolean;\n  public readonly queryRunnerUrlParamsInit: Record<string, any>;\n  public readonly queryRunnerUrlParamsRun: Record<string, any>;\n  public readonly queryTimeoutFallback: number | undefined;\n\n  /**\n   * @param datasetScale\n   * @param queryCount\n   * @param queryRecurrence\n   * @param generateHdt\n   * @param hookSparqlEndpoint\n   * @param endpointUrl\n   * @param queryRunnerReplication\n   * @param queryRunnerWarmupRounds\n   * @param queryRunnerRecordTimestamps\n   * @param queryRunnerRecordHttpRequests\n   * @param queryRunnerUrlParamsInit - @range {json}\n   * @param queryRunnerUrlParamsRun - @range {json}\n   * @param queryTimeoutFallback\n   */\n  public constructor(\n    datasetScale: number,\n    queryCount: number,\n    queryRecurrence: number,\n    generateHdt: boolean,\n    hookSparqlEndpoint: Hook,\n    endpointUrl: string,\n    queryRunnerReplication: number,\n    queryRunnerWarmupRounds: number,\n    queryRunnerRecordTimestamps: boolean,\n    queryRunnerRecordHttpRequests: boolean,\n    queryRunnerUrlParamsInit: Record<string, any>,\n    queryRunnerUrlParamsRun: Record<string, any>,\n    queryTimeoutFallback: number | undefined,\n  ) {\n    this.datasetScale = datasetScale;\n    this.queryCount = queryCount;\n    this.queryRecurrence = queryRecurrence;\n    this.generateHdt = generateHdt;\n    this.hookSparqlEndpoint = hookSparqlEndpoint;\n    this.endpointUrl = endpointUrl;\n    this.queryRunnerReplication = queryRunnerReplication;\n    this.queryRunnerWarmupRounds = queryRunnerWarmupRounds;\n    this.queryRunnerRecordTimestamps = queryRunnerRecordTimestamps;\n    this.queryRunnerRecordHttpRequests = queryRunnerRecordHttpRequests;\n    this.queryRunnerUrlParamsInit = queryRunnerUrlParamsInit;\n    this.queryRunnerUrlParamsRun = queryRunnerUrlParamsRun;\n    this.queryTimeoutFallback = queryTimeoutFallback;\n  }\n\n  public async prepare(context: ITaskContext, forceOverwriteGenerated: boolean): Promise<void> {\n    // Prepare hook\n    await this.hookSparqlEndpoint.prepare(context, forceOverwriteGenerated);\n\n    // Ensure logs directory exists\n    await fs.ensureDir(Path.join(context.experimentPaths.output, 'logs'));\n\n    // Prepare dataset\n    context.logger.info(`Generating WatDiv dataset and queries`);\n    if (!forceOverwriteGenerated && await fs.pathExists(Path.join(context.experimentPaths.generated, 'dataset.nt'))) {\n      context.logger.info(`  Skipped`);\n    } else {\n      await context.docker.imagePuller.pull({ repoTag: ExperimentWatDiv.DOCKER_IMAGE_WATDIV });\n      await (await context.docker.containerCreator.start({\n        imageName: ExperimentWatDiv.DOCKER_IMAGE_WATDIV,\n        cmdArgs: [ '-s', String(this.datasetScale), '-q', String(this.queryCount), '-r', String(this.queryRecurrence) ],\n        hostConfig: {\n          Binds: [\n            `${context.experimentPaths.generated}:/output`,\n          ],\n        },\n        logFilePath: Path.join(context.experimentPaths.output, 'logs', 'watdiv-generation.txt'),\n      })).join();\n    }\n\n    if (this.generateHdt) {\n      // Create HDT file\n      context.logger.info(`Converting WatDiv dataset to HDT`);\n\n      if (!forceOverwriteGenerated &&\n        await fs.pathExists(Path.join(context.experimentPaths.generated, 'dataset.hdt'))) {\n        context.logger.info(`  Skipped`);\n      } else {\n        // Pull HDT Docker image\n        await context.docker.imagePuller.pull({ repoTag: ExperimentWatDiv.DOCKER_IMAGE_HDT });\n\n        // Remove any existing index files\n        await fs.rm(Path.join(context.experimentPaths.generated, 'dataset.hdt.index.v1-1'), { force: true });\n\n        // Convert dataset to HDT\n        await (await context.docker.containerCreator.start({\n          imageName: ExperimentWatDiv.DOCKER_IMAGE_HDT,\n          cmdArgs: [ 'rdf2hdt', '/output/dataset.nt', '/output/dataset.hdt' ],\n          hostConfig: {\n            Binds: [\n              `${context.experimentPaths.generated}:/output`,\n            ],\n          },\n          logFilePath: Path.join(context.experimentPaths.output, 'logs', 'watdiv-hdt.txt'),\n        })).join();\n\n        // Generate HDT index file\n        await (await context.docker.containerCreator.start({\n          imageName: ExperimentWatDiv.DOCKER_IMAGE_HDT,\n          cmdArgs: [ 'hdtSearch', '/output/dataset.hdt', '-q', '0' ],\n          hostConfig: {\n            Binds: [\n              `${context.experimentPaths.generated}:/output`,\n            ],\n          },\n          logFilePath: Path.join(context.experimentPaths.output, 'logs', 'watdiv-hdt-index.txt'),\n        })).join();\n      }\n    }\n  }\n\n  public async run(context: ITaskContext): Promise<void> {\n    // Setup SPARQL endpoint\n    const endpointProcessHandler = await this.hookSparqlEndpoint.start(context);\n    const closeProcess = secureProcessHandler(endpointProcessHandler, context);\n\n    // Initiate SPARQL benchmark runner\n    let stopEndpointStats: () => void;\n    const results = await new SparqlBenchmarkRunner({\n      endpoint: this.endpointUrl,\n      querySets: await readQueries(Path.join(context.experimentPaths.generated, 'queries')),\n      replication: this.queryRunnerReplication,\n      warmup: this.queryRunnerWarmupRounds,\n      timestampsRecording: this.queryRunnerRecordTimestamps,\n      logger: (message: string) => process.stderr.write(message),\n      additionalUrlParamsInit: new URLSearchParams(this.queryRunnerUrlParamsInit),\n      additionalUrlParamsRun: new URLSearchParams(this.queryRunnerUrlParamsRun),\n      timeout: this.queryTimeoutFallback,\n    }).run({\n      async onStart() {\n        // Collect stats\n        stopEndpointStats = await endpointProcessHandler.startCollectingStats();\n\n        // Breakpoint right before starting queries.\n        if (context.breakpointBarrier) {\n          await context.breakpointBarrier();\n        }\n      },\n      async onStop() {\n        stopEndpointStats();\n      },\n    });\n\n    // Write results\n    const resultsOutput = context.experimentPaths.output;\n    if (!await fs.pathExists(resultsOutput)) {\n      await fs.mkdir(resultsOutput);\n    }\n    context.logger.info(`Writing results to ${resultsOutput}\\n`);\n    await writeBenchmarkResults(\n      results,\n      Path.join(resultsOutput, 'query-times.csv'),\n      this.queryRunnerRecordTimestamps,\n      [\n        ...this.queryRunnerRecordHttpRequests ? [ 'httpRequests' ] : [],\n      ],\n    );\n\n    // Close process safely\n    await closeProcess();\n  }\n\n  public async clean(context: ITaskContext, cleanTargets: ICleanTargets): Promise<void> {\n    await this.hookSparqlEndpoint.clean(context, cleanTargets);\n  }\n}\n"]}