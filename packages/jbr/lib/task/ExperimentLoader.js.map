{"version":3,"file":"ExperimentLoader.js","sourceRoot":"","sources":["ExperimentLoader.ts"],"names":[],"mappings":"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","sourcesContent":["import * as Path from 'path';\nimport { ComponentsManager } from 'componentsjs';\nimport { GenericsContext } from 'componentsjs/lib/preprocess/GenericsContext';\nimport {\n  ParameterPropertyHandlerRange,\n} from 'componentsjs/lib/preprocess/parameterproperty/ParameterPropertyHandlerRange';\nimport * as fs from 'fs-extra';\nimport type { CombinationProvider } from '../..';\nimport { createExperimentPaths } from '../cli/CliHelpers';\nimport { ErrorHandled } from '../cli/ErrorHandled';\nimport type { Experiment } from '../experiment/Experiment';\nimport type { ExperimentHandler } from '../experiment/ExperimentHandler';\nimport type { HookHandler } from '../hook/HookHandler';\nimport type { IExperimentPaths } from './ITaskContext';\n\n/**\n * Loads and instantiates an experiment by config.\n */\nexport class ExperimentLoader {\n  public static readonly CONFIG_NAME = 'jbr-experiment.json';\n  public static readonly CONFIG_TEMPLATE_NAME = 'jbr-experiment.json.template';\n  public static readonly COMBINATIONS_NAME = 'jbr-combinations.json';\n  public static readonly PACKAGEJSON_NAME = 'package.json';\n  public static readonly PREPAREDMARKER_PATH = [ 'generated', '.prepared' ];\n  public static readonly IRI_EXPERIMENT_HANDLER = `https://linkedsoftwaredependencies.org/bundles/npm/jbr/^2.0.0/components/experiment/ExperimentHandler.jsonld#ExperimentHandler`;\n  public static readonly IRI_HOOK_HANDLER = `https://linkedsoftwaredependencies.org/bundles/npm/jbr/^2.0.0/components/hook/HookHandler.jsonld#HookHandler`;\n\n  private readonly componentsManager: ComponentsManager<any>;\n\n  public constructor(\n    componentsManager: ComponentsManager<any>,\n  ) {\n    this.componentsManager = componentsManager;\n  }\n\n  /**\n   * Create a new ExperimentLoader based on the given main module path.\n   * @param mainModulePath Path from which dependencies should be searched for.\n   *                       Typically the path of the current package.\n   */\n  public static async build<T>(mainModulePath: string): Promise<ExperimentLoader> {\n    return new ExperimentLoader(await ExperimentLoader.buildComponentsManager<T>(mainModulePath));\n  }\n\n  public static async getExperimentName(experimentRoot: string): Promise<string> {\n    try {\n      const data = JSON.parse(await fs.readFile(Path.join(experimentRoot, 'package.json'), 'utf8'));\n      return data.name;\n    } catch {\n      return 'dummy';\n    }\n  }\n\n  public static async buildComponentsManager<T>(mainModulePath: string): Promise<ComponentsManager<T>> {\n    return await ComponentsManager.build({\n      mainModulePath,\n      skipContextValidation: true,\n      logLevel: 'warn',\n    });\n  }\n\n  public static getDefaultExperimentIri(experimentName: string): string {\n    return `urn:jbr:${experimentName}`;\n  }\n\n  /**\n   * Instantiate experiments from the given experiment path.\n   * @param experimentName The name of the experiment.\n   * @param experimentPath Path to an experiment directory.\n   */\n  public async instantiateExperiments(experimentName: string, experimentPath: string): Promise<{\n    experiments: Experiment[];\n    experimentPathsArray: IExperimentPaths[];\n    combinationProvider?: CombinationProvider;\n  }> {\n    // Determine experiment name and IRI\n    const experimentIri = ExperimentLoader.getDefaultExperimentIri(experimentName);\n\n    // Check if combinations file exists\n    const configs: { path: string; iri: string }[] = [];\n    const experimentPathsArray: IExperimentPaths[] = [];\n    let combinationProvider: CombinationProvider | undefined;\n    if (await ExperimentLoader.isCombinationsExperiment(experimentPath)) {\n      // Determine combinations\n      combinationProvider = await this.instantiateCombinationProvider(experimentName, experimentPath);\n      const combinations = combinationProvider.getFactorCombinations();\n\n      const combinationsPath = Path.join(experimentPath, 'combinations');\n      for (const [ combinationId ] of combinations.entries()) {\n        // Validate combination\n        const combinationIdString = ExperimentLoader.getCombinationIdString(combinationId);\n        const combinationInstancePath = Path.join(combinationsPath, combinationIdString);\n        if (!await fs.pathExists(combinationInstancePath)) {\n          throw new ErrorHandled(`Detected invalid combination-based experiment. It is required to (re-)run 'jbr generate-combinations' first.`);\n        }\n\n        // Determine config file\n        const combinationInstanceConfigPath = Path.join(combinationInstancePath, ExperimentLoader.CONFIG_NAME);\n        configs.push({\n          iri: ExperimentLoader.getCombinationExperimentIri(experimentIri, combinationIdString),\n          path: combinationInstanceConfigPath,\n        });\n        const experimentPaths = createExperimentPaths(combinationInstancePath, combinationId);\n        if (combinationProvider.commonGenerated) {\n          experimentPaths.generated = Path.join(experimentPath, 'generated');\n        }\n        experimentPathsArray.push(experimentPaths);\n      }\n    } else {\n      // Determine config file\n      configs.push({\n        iri: experimentIri,\n        path: Path.join(experimentPath, ExperimentLoader.CONFIG_NAME),\n      });\n      experimentPathsArray.push(createExperimentPaths(experimentPath));\n    }\n\n    // Check if config exists\n    for (const config of configs) {\n      if (!await fs.pathExists(config.path)) {\n        throw new Error(`Experiment config file could not be found at '${config.path}'`);\n      }\n    }\n\n    // Instantiate valid config\n    return {\n      experiments: await Promise.all(configs\n        .map(config => this.instantiateFromConfig<Experiment>(config.path, config.iri))),\n      experimentPathsArray,\n      combinationProvider,\n    };\n  }\n\n  /**\n   * Instantiate an experiment combinations provider from the given experiment path.\n   * @param experimentName The name of the experiment.\n   * @param experimentPath Path to an experiment directory.\n   */\n  public async instantiateCombinationProvider(\n    experimentName: string,\n    experimentPath: string,\n  ): Promise<CombinationProvider> {\n    // Determine combinations name and IRI\n    const experimentIri = ExperimentLoader.getDefaultExperimentIri(experimentName);\n    const combinationsPath = Path.join(experimentPath, ExperimentLoader.COMBINATIONS_NAME);\n    const combinationsIri = `${experimentIri}-combinations`;\n    return await this.instantiateFromConfig<CombinationProvider>(combinationsPath, combinationsIri);\n  }\n\n  /**\n   * Instantiate an experiment from the given config file.\n   * @param configPath Path to an experiment configuration file.\n   * @param experimentIri IRI of the experiment to instantiate.\n   */\n  public async instantiateFromConfig<E>(configPath: string, experimentIri: string): Promise<E> {\n    await this.componentsManager.configRegistry.register(configPath);\n    return await this.componentsManager.instantiate(experimentIri);\n  }\n\n  protected async discoverComponents<C extends { id: string }>(componentType: string):\n  Promise<Record<string, { handler: C; contexts: string[] }>> {\n    // Index available package.json by package name\n    const packageJsons: Record<string, { contents: any; path: string }> = {};\n    for (const [ path, packageJson ] of Object.entries(this.componentsManager.moduleState.packageJsons)) {\n      packageJsons[packageJson.name] = { contents: packageJson, path };\n    }\n\n    const rangeHandler = new ParameterPropertyHandlerRange(this.componentsManager.objectLoader, false);\n\n    // Collect and instantiate all available experiment handlers\n    const handlers: Record<string, { handler: C; contexts: string[] }> = {};\n    for (const component of Object.values(this.componentsManager.componentResources)) {\n      const hasTypeError = rangeHandler.hasType(\n        component,\n        this.componentsManager.objectLoader.createCompactedResource(componentType),\n        new GenericsContext(this.componentsManager.objectLoader, []),\n        undefined,\n        [],\n        {},\n      );\n\n      if (!hasTypeError && component.value !== componentType) {\n        const handler = await this.componentsManager.configConstructorPool\n          .instantiate(this.componentsManager.objectLoader.createCompactedResource({\n            types: component,\n          }), {});\n        if (handlers[handler.id]) {\n          throw new Error(`Double registration of component id '${handler.id}' detected`);\n        }\n\n        // Determine contexts for this component's module\n        const packageName = component.property.module.property.requireName.value;\n        const packageJson = packageJsons[packageName];\n        if (!packageJson) {\n          throw new ErrorHandled(`Could not find a package.json for '${packageName}'`);\n        }\n        const contexts = Object.keys(packageJson.contents['lsd:contexts']);\n\n        handlers[handler.id] = { handler, contexts };\n      }\n    }\n\n    return handlers;\n  }\n\n  public discoverExperimentHandlers():\n  Promise<Record<string, { handler: ExperimentHandler<any>; contexts: string[] }>> {\n    return this.discoverComponents(ExperimentLoader.IRI_EXPERIMENT_HANDLER);\n  }\n\n  public discoverHookHandlers(): Promise<Record<string, { handler: HookHandler<any>; contexts: string[] }>> {\n    return this.discoverComponents(ExperimentLoader.IRI_HOOK_HANDLER);\n  }\n\n  /**\n   * Get the path of the prepared marker file.\n   * @param experimentPath Path of an experiment.\n   */\n  public static getPreparedMarkerPath(experimentPath: string): string {\n    return Path.join(experimentPath, ...ExperimentLoader.PREPAREDMARKER_PATH);\n  }\n\n  /**\n   * Check if the given experiment contains the prepared marker file.\n   * @param experimentPath Path of an experiment.\n   */\n  public static async isExperimentPrepared(experimentPath: string): Promise<boolean> {\n    return await fs.pathExists(ExperimentLoader.getPreparedMarkerPath(experimentPath));\n  }\n\n  /**\n   * Throw an error if the given experiment does not contain the prepared marker file.\n   * @param experimentPath Path of an experiment.\n   */\n  public static async requireExperimentPrepared(experimentPath: string): Promise<void> {\n    if (!await ExperimentLoader.isExperimentPrepared(experimentPath)) {\n      throw new ErrorHandled(`The experiment at '${experimentPath}' has not been prepared successfully yet, invoke 'jbr prepare' first.`);\n    }\n  }\n\n  /**\n   * Check if the given experiment path is a combinations-based experiment.\n   * @param experimentPath Path of an experiment.\n   * @throws if the combinations-based experiment is invalid.\n   */\n  public static async isCombinationsExperiment(experimentPath: string): Promise<boolean> {\n    const combinationsPath = Path.join(experimentPath, ExperimentLoader.COMBINATIONS_NAME);\n    const combinationsPathExists = await fs.pathExists(combinationsPath);\n    const configTemplatePath = Path.join(experimentPath, ExperimentLoader.CONFIG_TEMPLATE_NAME);\n    const configTemplatePathExists = await fs.pathExists(configTemplatePath);\n    if (combinationsPathExists !== configTemplatePathExists) {\n      if (combinationsPathExists) {\n        throw new Error(`Found '${ExperimentLoader.COMBINATIONS_NAME}' for a combinations-based experiment, but '${ExperimentLoader.CONFIG_TEMPLATE_NAME}' is missing.`);\n      } else {\n        throw new Error(`Found '${ExperimentLoader.CONFIG_TEMPLATE_NAME}' for a combinations-based experiment, but '${ExperimentLoader.COMBINATIONS_NAME}' is missing.`);\n      }\n    }\n    return Boolean(combinationsPathExists && configTemplatePathExists);\n  }\n\n  /**\n   * Throw an error if the given experiment is not a combinations-based experiment.\n   * @param experimentPath Path of an experiment.\n   */\n  public static async requireCombinationsExperiment(experimentPath: string): Promise<void> {\n    if (!await ExperimentLoader.isCombinationsExperiment(experimentPath)) {\n      throw new Error(`A combinations-based experiments requires the files '${ExperimentLoader.CONFIG_TEMPLATE_NAME}' and '${ExperimentLoader.COMBINATIONS_NAME}'.`);\n    }\n  }\n\n  /**\n   * Convert a given numerical combination id to a string-based id.\n   * @param combinationId A numerical combination id.\n   */\n  public static getCombinationIdString(combinationId: number): string {\n    return `combination_${combinationId}`;\n  }\n\n  /**\n   * Determine the IRI of a combination\n   * @param experimentIri An experiment IRI.\n   * @param combinationIdString A combination id.\n   */\n  public static getCombinationExperimentIri(experimentIri: string, combinationIdString: string): string {\n    return `${experimentIri}:${combinationIdString}`;\n  }\n}\n"]}