{"version":3,"file":"FullFactorialCombinationProvider.js","sourceRoot":"","sources":["FullFactorialCombinationProvider.ts"],"names":[],"mappings":";;;AAEA;;GAEG;AACH,MAAa,gCAAgC;IAI3C;;;OAGG;IACH,YAAmB,OAA8B,EAAE,eAAe,GAAG,KAAK;QACxE,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;QACvB,IAAI,CAAC,eAAe,GAAG,eAAe,CAAC;IACzC,CAAC;IAEM,qBAAqB;QAC1B,oCAAoC;QACpC,IAAI,YAAY,GAAwB,CAAC,EAAE,CAAC,CAAC;QAC7C,KAAK,MAAM,CAAE,MAAM,EAAE,MAAM,CAAE,IAAI,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,EAAE;YAC7D,MAAM,kBAAkB,GAA0B,EAAE,CAAC;YACrD,KAAK,MAAM,KAAK,IAAI,MAAM,EAAE;gBAC1B,6CAA6C;gBAC7C,MAAM,gBAAgB,GAAG,YAAY,CAAC,GAAG,CAAC,iBAAiB,CAAC,EAAE,CAAC,mBAAM,iBAAiB,EAAG,CAAC,CAAC;gBAC3F,kBAAkB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBAE1C,8BAA8B;gBAC9B,KAAK,MAAM,eAAe,IAAI,gBAAgB,EAAE;oBAC9C,eAAe,CAAC,MAAM,CAAC,GAAG,KAAK,CAAC;iBACjC;aACF;YAED,kCAAkC;YAClC,YAAY,GAAG,kBAAkB,CAAC,IAAI,EAAE,CAAC;SAC1C;QAED,OAAO,YAAY,CAAC;IACtB,CAAC;CACF;AAnCD,4EAmCC","sourcesContent":["import type { CombinationProvider, FactorCombination } from './CombinationProvider';\n\n/**\n * For all the given factor values, provide all possible combinations.\n */\nexport class FullFactorialCombinationProvider implements CombinationProvider {\n  private readonly factors: Record<string, any[]>;\n  public readonly commonGenerated: boolean;\n\n  /**\n   * @param factors A hash of factor keys to an array of factor values. @range {json}\n   * @param commonGenerated If the prepare phase is identical across combinations.\n   */\n  public constructor(factors: Record<string, any[]>, commonGenerated = false) {\n    this.factors = factors;\n    this.commonGenerated = commonGenerated;\n  }\n\n  public getFactorCombinations(): FactorCombination[] {\n    // Calculate all matrix combinations\n    let combinations: FactorCombination[] = [{}];\n    for (const [ factor, values ] of Object.entries(this.factors)) {\n      const combinationsCopies: FactorCombination[][] = [];\n      for (const value of values) {\n        // Make a deep copy of the combinations array\n        const combinationsCopy = combinations.map(factorCombination => ({ ...factorCombination }));\n        combinationsCopies.push(combinationsCopy);\n\n        // Set the value in all copies\n        for (const combinationCopy of combinationsCopy) {\n          combinationCopy[factor] = value;\n        }\n      }\n\n      // Update the current combinations\n      combinations = combinationsCopies.flat();\n    }\n\n    return combinations;\n  }\n}\n"]}