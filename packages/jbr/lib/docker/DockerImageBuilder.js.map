{"version":3,"file":"DockerImageBuilder.js","sourceRoot":"","sources":["DockerImageBuilder.ts"],"names":[],"mappings":";;;AAIA;;GAEG;AACH,MAAa,kBAAkB;IAG7B,YAAmB,SAAoB;QACrC,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;IAC7B,CAAC;IAED;;;OAGG;IACI,KAAK,CAAC,KAAK,CAAC,OAAgC;QACjD,MAAM,WAAW,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,UAAU,CAAC;YAClD,OAAO,EAAE,OAAO,CAAC,GAAG;YACpB,GAAG,EAAE,CAAE,OAAO,CAAC,UAAU,EAAE,GAAG,OAAO,CAAC,cAAc,IAAI,EAAE,CAAE;SAC7D,EAAE;YACD,qCAAqC;YACrC,CAAC,EAAE,OAAO,CAAC,SAAS;YACpB,SAAS,EAAE,OAAO,CAAC,SAAS;YAC5B,UAAU,EAAE,OAAO,CAAC,UAAU;SAC/B,CAAC,CAAC;QACH,MAAM,MAAM,GAAU,MAAM,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;YAC1D,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,cAAc,CACjC,WAAW,EACX,CAAC,GAAiB,EAAE,GAAU,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC,EACnE,CAAC,IAAS,EAAE,EAAE;gBACZ,IAAI,IAAI,CAAC,MAAM,IAAI,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE;oBACrC,OAAO,CAAC,MAAM,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;iBAC5C;YACH,CAAC,CACF,CAAC;QACJ,CAAC,CAAC,CAAC;QACH,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,IAAI,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE;YACxD,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;SAClD;IACH,CAAC;IAED;;;;OAIG;IACI,YAAY,CAAC,OAAqB,EAAE,MAAc;QACvD,IAAI,WAAW,GAAW,OAAO,CAAC,cAAc,CAAC;QACjD,IAAI,aAAa,IAAI,OAAO,CAAC,eAAe,EAAE;YAC5C,WAAW,GAAG,GAAG,WAAW,gBAAgB,OAAO,CAAC,eAAe,CAAC,WAAW,EAAE,CAAC;SACnF;QACD,OAAO,kBAAkB,WAAW,IAAI,MAAM,EAAE,CAAC;IACnD,CAAC;CACF;AAjDD,gDAiDC","sourcesContent":["import type Dockerode from 'dockerode';\nimport type { Logger } from 'winston';\nimport type { ITaskContext } from '../../lib/task/ITaskContext';\n\n/**\n * Conveniently build a Docker image.\n */\nexport class DockerImageBuilder {\n  private readonly dockerode: Dockerode;\n\n  public constructor(dockerode: Dockerode) {\n    this.dockerode = dockerode;\n  }\n\n  /**\n   * Build an image\n   * @param options Image options\n   */\n  public async build(options: IDockerImageBuilderArgs): Promise<void> {\n    const buildStream = await this.dockerode.buildImage({\n      context: options.cwd,\n      src: [ options.dockerFile, ...options.auxiliaryFiles || [] ],\n    }, {\n      // eslint-disable-next-line id-length\n      t: options.imageName,\n      buildargs: options.buildArgs,\n      dockerfile: options.dockerFile,\n    });\n    const output: any[] = await new Promise((resolve, reject) => {\n      this.dockerode.modem.followProgress(\n        buildStream,\n        (err: Error | null, res: any[]) => err ? reject(err) : resolve(res),\n        (data: any) => {\n          if (data.stream && data.stream.trim()) {\n            options.logger.verbose(data.stream.trim());\n          }\n        },\n      );\n    });\n    if (output.length > 0 && output[output.length - 1].error) {\n      throw new Error(output[output.length - 1].error);\n    }\n  }\n\n  /**\n   * Obtain a proper image name within the current jbr experiment context with the given suffix.\n   * @param context A task context.\n   * @param suffix A suffix to add to the image name.\n   */\n  public getImageName(context: ITaskContext, suffix: string): string {\n    let pathContext: string = context.experimentName;\n    if ('combination' in context.experimentPaths) {\n      pathContext = `${pathContext}-combination_${context.experimentPaths.combination}`;\n    }\n    return `jbr-experiment-${pathContext}-${suffix}`;\n  }\n}\n\nexport interface IDockerImageBuilderArgs {\n  cwd: string;\n  dockerFile: string;\n  auxiliaryFiles?: string[];\n  imageName: string;\n  buildArgs?: Record<string, string>;\n  logger: Logger;\n}\n"]}