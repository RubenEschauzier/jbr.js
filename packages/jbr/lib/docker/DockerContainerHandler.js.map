{"version":3,"file":"DockerContainerHandler.js","sourceRoot":"","sources":["DockerContainerHandler.ts"],"names":[],"mappings":";;;;;;AAAA,4CAAoB;AAIpB;;GAEG;AACH,MAAa,sBAAsB;IASjC,YAAmB,SAA8B,EAAE,YAAmC,EAAE,aAAsB;QAC5G,IAAI,CAAC,SAAS,GAAG,SAAS,CAAC;QAC3B,IAAI,CAAC,YAAY,GAAG,YAAY,CAAC;QACjC,IAAI,CAAC,KAAK,GAAG,KAAK,CAAC;QACnB,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,KAAK,EAAE,GAAG,EAAE;YAC/B,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBAChC,IAAI,CAAC,YAAY,EAAE,CAAC;aACrB;YAED,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QACpB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,KAAY,EAAE,EAAE;YAC7C,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;gBAChC,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;aAC1B;YAED,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;QACvB,CAAC,CAAC,CAAC;QACH,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;QACnC,IAAI,CAAC,mBAAmB,GAAG,IAAI,GAAG,EAAc,CAAC;IACnD,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,KAAK;QAChB,IAAI;YACF,MAAM,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC;SAC7B;QAAC,WAAM;YACN,eAAe;SAChB;QACD,IAAI;YACF,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC;SAC/B;QAAC,WAAM;YACN,eAAe;SAChB;IACH,CAAC;IAED;;OAEG;IACI,KAAK,CAAC,IAAI;QACf,IAAI,IAAI,CAAC,OAAO,EAAE;YAChB,MAAM,IAAI,CAAC,OAAO,CAAC;SACpB;QACD,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE;YACf,MAAM,IAAI,OAAO,CAAO,CAAC,OAAO,EAAE,MAAM,EAAE,EAAE;gBAC1C,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC;gBACtC,IAAI,CAAC,YAAY,CAAC,EAAE,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;YACvC,CAAC,CAAC,CAAC;YACH,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,CAAC;SAC/B;IACH,CAAC;IAEM,KAAK,CAAC,oBAAoB;QAC/B,iEAAiE;QACjE,IAAI,CAAC,IAAI,CAAC,aAAa,EAAE;YACvB,MAAM,WAAW,GAAgC,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;YAChF,WAAW,CAAC,MAAM,EAAE,CAAC;YACrB,OAAO,GAAG,EAAE;gBACV,WAAW,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;YACzC,CAAC,CAAC;SACH;QAED,kCAAkC;QAClC,MAAM,GAAG,GAAG,YAAE,CAAC,iBAAiB,CAAC,IAAI,CAAC,aAAa,EAAE,MAAM,CAAC,CAAC;QAC7D,GAAG,CAAC,KAAK,CAAC,gEAAgE,CAAC,CAAC;QAE5E,wBAAwB;QACxB,MAAM,WAAW,GAAgC,MAAM,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;QAChF,WAAW,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QAChC,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,WAAW,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,KAAa,EAAE,EAAE;YACvC,MAAM,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;YAChC,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE;gBACxB,IAAI,IAAI,EAAE;oBACR,wGAAwG;oBACxG,IAAI,KAAK,EAAE;wBACT,KAAK,GAAG,KAAK,CAAC;wBACd,SAAS;qBACV;oBAED,IAAI,IAAI,CAAC;oBACT,IAAI;wBACF,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;qBACzB;oBAAC,WAAM;wBACN,SAAS;qBACV;oBAED,yEAAyE;oBACzE,IAAI,CAAC,IAAI,CAAC,QAAQ,EAAE;wBAClB,SAAS;qBACV;oBAED,2BAA2B;oBAC3B,IAAI,aAAa,GAAG,CAAC,CAAC;oBACtB,MAAM,QAAQ,GAAG,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,WAAW,GAAG,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,WAAW,CAAC;oBAChG,MAAM,WAAW,GAAG,IAAI,CAAC,SAAS,CAAC,gBAAgB,GAAG,IAAI,CAAC,YAAY,CAAC,gBAAgB,CAAC;oBACzF,IAAI,WAAW,GAAG,CAAC,EAAE;wBACnB,aAAa,GAAG,QAAQ,GAAG,WAAW,GAAG,GAAG,CAAC;qBAC9C;oBAED,yBAAyB;oBACzB,MAAM,MAAM,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC;oBACvC,MAAM,gBAAgB,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,GAAG,GAAG,CAAC;oBAEjF,gBAAgB;oBAChB,IAAI,aAAa,GAAG,CAAC,CAAC;oBACtB,IAAI,gBAAgB,GAAG,CAAC,CAAC;oBACzB,KAAK,MAAM,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE;wBAChD,aAAa,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC;wBACjD,gBAAgB,IAAI,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,QAAQ,CAAC;qBACrD;oBAED,GAAG,CAAC,KAAK,CAAC,GAAG,aAAa,IAAI,MAAM,IAAI,gBAAgB,IAAI,aAAa,IAAI,gBAAgB,IAAI,CAAC,CAAC;iBACpG;aACF;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,GAAG,EAAE;YACV,WAAW,CAAC,kBAAkB,CAAC,MAAM,CAAC,CAAC;YACvC,GAAG,CAAC,GAAG,EAAE,CAAC;QACZ,CAAC,CAAC;IACJ,CAAC;IAEM,qBAAqB,CAAC,OAAqD;QAChF,IAAI,CAAC,mBAAmB,CAAC,GAAG,CAAC,OAAO,CAAC,CAAC;IACxC,CAAC;IAEM,wBAAwB,CAAC,OAAqD;QACnF,IAAI,CAAC,mBAAmB,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IAC3C,CAAC;IAES,YAAY,CAAC,KAAa;QAClC,KAAK,MAAM,mBAAmB,IAAI,IAAI,CAAC,mBAAmB,EAAE;YAC1D,mBAAmB,CAAC,oBAAoB,IAAI,CAAC,SAAS,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC,CAAC;SACrE;IACH,CAAC;CACF;AAnJD,wDAmJC","sourcesContent":["import fs from 'fs';\nimport type Dockerode from 'dockerode';\nimport type { ProcessHandler } from '../experiment/ProcessHandler';\n\n/**\n * Docker container wrapped in a convenience datastructure.\n */\nexport class DockerContainerHandler implements ProcessHandler {\n  public readonly container: Dockerode.Container;\n  public readonly outputStream: NodeJS.ReadableStream;\n  public readonly statsFilePath?: string;\n  public readonly terminationHandlers: Set<(processName: string, error?: Error) => void>;\n\n  public ended: boolean;\n  public errored?: Error;\n\n  public constructor(container: Dockerode.Container, outputStream: NodeJS.ReadableStream, statsFilePath?: string) {\n    this.container = container;\n    this.outputStream = outputStream;\n    this.ended = false;\n    this.outputStream.on('end', () => {\n      if (!this.ended && !this.errored) {\n        this.onTerminated();\n      }\n\n      this.ended = true;\n    });\n    this.outputStream.on('error', (error: Error) => {\n      if (!this.ended && !this.errored) {\n        this.onTerminated(error);\n      }\n\n      this.errored = error;\n    });\n    this.statsFilePath = statsFilePath;\n    this.terminationHandlers = new Set<() => void>();\n  }\n\n  /**\n   * Stop and clean this container\n   */\n  public async close(): Promise<void> {\n    try {\n      await this.container.kill();\n    } catch {\n      // Ignore error\n    }\n    try {\n      await this.container.remove();\n    } catch {\n      // Ignore error\n    }\n  }\n\n  /**\n   * Wait until this container is ended.\n   */\n  public async join(): Promise<void> {\n    if (this.errored) {\n      throw this.errored;\n    }\n    if (!this.ended) {\n      await new Promise<void>((resolve, reject) => {\n        this.outputStream.on('error', reject);\n        this.outputStream.on('end', resolve);\n      });\n      await this.container.remove();\n    }\n  }\n\n  public async startCollectingStats(): Promise<() => void> {\n    // Just consume the stats stream if we don't have a statsFilePath\n    if (!this.statsFilePath) {\n      const statsStream: NodeJS.ReadableStream = <any> await this.container.stats({});\n      statsStream.resume();\n      return () => {\n        statsStream.removeAllListeners('data');\n      };\n    }\n\n    // Create a CSV file output stream\n    const out = fs.createWriteStream(this.statsFilePath, 'utf8');\n    out.write('cpu_percentage,memory,memory_percentage,received,transmitted\\n');\n\n    // Read the stats stream\n    const statsStream: NodeJS.ReadableStream = <any> await this.container.stats({});\n    statsStream.setEncoding('utf8');\n    let first = true;\n    statsStream.on('data', (stats: string) => {\n      const lines = stats.split('\\n');\n      for (const line of lines) {\n        if (line) {\n          // Skip first output, because we don't have a reference to create a delta with (CPU will always be zero)\n          if (first) {\n            first = false;\n            continue;\n          }\n\n          let data;\n          try {\n            data = JSON.parse(line);\n          } catch {\n            continue;\n          }\n\n          // Skip line if network hasn't been set yet, or has been shutdown already\n          if (!data.networks) {\n            continue;\n          }\n\n          // Calculate CPU percentage\n          let cpuPercentage = 0;\n          const cpuDelta = data.cpu_stats.cpu_usage.total_usage - data.precpu_stats.cpu_usage.total_usage;\n          const systemDelta = data.cpu_stats.system_cpu_usage - data.precpu_stats.system_cpu_usage;\n          if (systemDelta > 0) {\n            cpuPercentage = cpuDelta / systemDelta * 100;\n          }\n\n          // Calculate memory usage\n          const memory = data.memory_stats.usage;\n          const memoryPercentage = data.memory_stats.usage / data.memory_stats.limit * 100;\n\n          // Calculate I/O\n          let receivedBytes = 0;\n          let transmittedBytes = 0;\n          for (const network of Object.keys(data.networks)) {\n            receivedBytes += data.networks[network].rx_bytes;\n            transmittedBytes += data.networks[network].tx_bytes;\n          }\n\n          out.write(`${cpuPercentage},${memory},${memoryPercentage},${receivedBytes},${transmittedBytes}\\n`);\n        }\n      }\n    });\n\n    return () => {\n      statsStream.removeAllListeners('data');\n      out.end();\n    };\n  }\n\n  public addTerminationHandler(handler: (processName: string, error?: Error) => void): void {\n    this.terminationHandlers.add(handler);\n  }\n\n  public removeTerminationHandler(handler: (processName: string, error?: Error) => void): void {\n    this.terminationHandlers.delete(handler);\n  }\n\n  protected onTerminated(error?: Error): void {\n    for (const terminationListener of this.terminationHandlers) {\n      terminationListener(`Docker container ${this.container.id}`, error);\n    }\n  }\n}\n"]}